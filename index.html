<script>
/*
IMPROVEMENTS (arguably features):
  - diamond resize bit odd with other layers.
  - joiner layer with arrow heads won't always show - zindex.
  - captures on every change instead of mouseup
  - improve diagonal lines
  - clever resize: text in boxes main issue
*/

var layerManager;
var eventManager;
var externalHookManager;
var areaSelectManager;
var modeMaster;
var charManager;
var themeManager;
var bodyComponent;

var canvas;

const ArrowKeyGroup = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];

//////////////////
////// UTILS /////
//////////////////

function reportError(message) {
  console.log(message);
}

function debugError(message) {
  console.log(`[DEBUG]: ${message}`);
}

function roundHalf(value) {
  return parseInt(Math.round(value));
}

function roundUp(value) {
  return parseInt(Math.ceil(value));
}

function roundDown(value) {
  return parseInt(Math.floor(value));
}

function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function sum(arr) {
  return arr.reduce((a, b) => a + b, 0);
}

function keyGroup(...names) {
  return names.join(",");
}

///////////////////
////// THEMES /////
///////////////////

class Theme {

  static Color = {
    blue         : "#0394fc",
    darkBlue     : "#0069b5",
    darkestBlue  : "#1a3540",
    lightestBlue : "#baebff",
    lightRed     : "#ff9494",
    red          : "#f52f2c",
    darkRed      : "#9e1910",
    darkestRed   : "#381111",
    black        : "black",
    white        : "white",
    none         : "transparent",
    pink         : "#ff78db",
    green        : "#49d65c",
    darkGreen    : "#11381b",
    lightGreen   : "#bdffdb",
    orange       : "orange",
    grey         : "#525252",
  }

  config = {
    bodyFgColor: Theme.Color.none,
    bodyBgColor: Theme.Color.none,
    bodyFont: "monospace",

    buttonBgColor: Theme.Color.black,
    buttonFgColor: Theme.Color.white,
    buttonBorderColor: Theme.Color.black,
    buttonSelectedBgColor: Theme.Color.blue,
    buttonClickBgColor: Theme.Color.blue,

    canvasBgColor: Theme.Color.none,

    pixelNormalBgColor: Theme.Color.none,
    pixelNormalFgColor: Theme.Color.white,
    pixelSelectedBgColor: Theme.Color.none,
    pixelSelectedFgColor: Theme.Color.darkBlue,
    pixelResizeBgColor: Theme.Color.red,
    pixelJointBgColor: Theme.Color.pink,
    pixelJointNearBgColor: Theme.Color.green,
    pixelCursorColor: Theme.Color.orange,

    areaSelectionBgColor: Theme.Color.blue,

    informerDefaultBgColor: Theme.Color.blue,
    informerGoodBgColor: Theme.Color.green,
    informerBadBgColor: Theme.Color.red,

    informerDefaultFgColor: Theme.Color.black,
    informerGoodFgColor: Theme.Color.black,
    informerBadFgColor: Theme.Color.black,

    canvasFont: "monospace",

    warningRed: Theme.Color.red,
  }

  constructor(config) {
    for (let key in config) {
      this.config[key] = config[key];
    }
  }
}

class ThemeManager {

  defaultTheme = localStorage.getItem("theme") || "darkTheme";

  themes = {
    darkTheme: new Theme(
      {
        bodyBgColor: Theme.Color.black,
        bodyFgColor: Theme.Color.white,
        buttonBgColor: Theme.Color.black,
        buttonFgColor: Theme.Color.white,
        buttonBorderColor: Theme.Color.grey,

        pixelCursorColor: Theme.Color.white,
        pixelNormalFgColor: Theme.Color.white,
        pixelResizeBgColor: Theme.Color.blue,
        pixelJointNearBgColor: Theme.Color.pink,
        pixelJointBgColor: Theme.Color.green,
        areaSelectionBgColor: Theme.Color.darkestBlue,

        //informerDefaultBgColor: Theme.Color.blue,
        //informerGoodBgColor: Theme.Color.green,
        //informerBadBgColor: Theme.Color.red,
      }
    ),
    lightTheme: new Theme(
      {
        bodyBgColor: Theme.Color.white,
        bodyFgColor: Theme.Color.black,
        buttonBgColor: Theme.Color.white,
        buttonFgColor: Theme.Color.black,
        buttonBorderColor: Theme.Color.black,

        pixelCursorColor: Theme.Color.black,
        pixelNormalFgColor: Theme.Color.black,
        pixelResizeBgColor: Theme.Color.blue,
        pixelJointNearBgColor: Theme.Color.pink,
        pixelJointBgColor: Theme.Color.green,

        //informerDefaultBgColor: Theme.Color.blue,
        //informerGoodBgColor: Theme.Color.lightGreen,
        //informerBadBgColor: Theme.Color.lightRed,

        areaSelectionBgColor: Theme.Color.lightestBlue,
      }
    ),
    consoleTheme: new Theme(
      {
        bodyBgColor: Theme.Color.black,
        bodyFgColor: Theme.Color.green,
        buttonBgColor: Theme.Color.black,
        buttonFgColor: Theme.Color.green,
        buttonBorderColor: Theme.Color.green,
        buttonSelectedBgColor: Theme.Color.darkRed,

        pixelSelectedFgColor: Theme.Color.lightGreen,
        pixelResizeBgColor: Theme.Color.lightGreen,
        pixelCursorColor: Theme.Color.green,
        pixelNormalFgColor: Theme.Color.green,
        pixelJointNearBgColor: Theme.Color.lightGreen,
        pixelJointBgColor: Theme.Color.red,

        //informerDefaultBgColor: Theme.Color.blue,
        //informerGoodBgColor: Theme.Color.darkGreen,
        //informerBadBgColor: Theme.Color.red,

        areaSelectionBgColor: Theme.Color.darkRed,
      }
    ),
  }

  constructor() {
    this.setTheme(this.defaultTheme);
  }

  getTheme() {
    return this.currentTheme.config;
  }

  setTheme(theme) {
    localStorage.setItem("theme", theme);
    this.currentTheme = this.themes[theme];
  }

  renderTheme() {
    layerManager.refresh(() => bodyComponent.renderTheme());
  }
}

//////////////////
////// MODES /////
//////////////////

class ModeMaster {

  constructor() {
    this._modes = ["select"];
    this.callbacks = [];
  }

  registerCallback(func) {
    this.callbacks.push(func);
  }

  modeChangedCallback() {
    for (var func of this.callbacks) func();
  }

  makeFunc(instruction) {
    // This just gives dispatchers a prettier notation...
    // e.g () => modeMaster.has("x", "y") becomes [modeMaster.has, "x", "y"]
    return (instruction.length)? instruction[0].bind(this, ...instruction.slice(1)): () => true;
  }

  change(beforeMode, afterMode) {
    let index = this._modes.indexOf(beforeMode);
    if (index == -1) return;
    this._modes[index] = afterMode;
    this.modeChangedCallback();
  }

  toggle(mode) {
    if (this.has(mode)) {
      this.remove(mode);
    } else {
      this.add(mode);
    }
  }

  remove(...modes) {
    modes.forEach((mode) => {
      let index = this._modes.indexOf(mode);
      if (index == -1) return;
      this._modes.splice(index, 1);
    });
    this.modeChangedCallback();
  }

  reset(...modes) {
    this._modes = modes;
    this.modeChangedCallback();
  }

  add(...modes) {
    modes = modes.filter(mode => !this.has(mode));
    this._modes = this._modes.concat(modes);
    this.modeChangedCallback();
  }

  has(...modes) {
    return modes.map((mode) => this._modes.includes(mode)).every(Boolean);
  }

  hasAny() {
    return this._modes.length > 0;
  }

  hasOr(...modes) {
    return modes.map((mode) => this._modes.includes(mode)).some(Boolean);
  }

  is(...modes) {
    return this._modes.toString() == modes.toString();
  }

  isDrawyMode(layerMode) {
    // Returns for any draw-related mode (for a given layer).
    return this.hasOr("draw", "drawing", "writing") && this.has(layerMode);
  }

  removeLayerModes() {
    layerManager.getLayerTypes().forEach(name => this.remove(name));
    this.remove("line");
    this.remove("line-based");
  }

  getLayerType() {
    for (let type of layerManager.getLayerTypes()) {
      if (this.has(type)) return type;
    }
  }
  setSelectedLayerMode(layer) {
    this.removeLayerModes();
    this.add(layer.getType());

    // Rules for dynamic layer modes
    if (layer.isLine()) this.add("line");
    if (layer.isLineBased()) this.add("line-based");
  }
}


////////////////
//// EVENTS ////
////////////////
class BaseExternalHookManager {
  /*
    This class should be overridden by optional dependencies
    allowing upstream functionality for specific hooks coming from this core app.

    E.g It is used to trigger server hooks for the server layer which,
    by design, is optionally attached.

    I want this file to open as an index.html and work out-of-the box,
    with 0 dependencies on a server, packaging, etc.
  */

  async getShortKeyUrl() {
    // Without a server, we return an empty short key. 
    return "";
  }

}


class EventDef {
  constructor(modeCondition, modeUpdate, callback=()=>{}) {
    this.callback = callback;
    this.condition = modeMaster.makeFunc(modeCondition);
    this.update = modeMaster.makeFunc(modeUpdate);
  }

  run(event) {
    if (this.condition()) {
      this.update();
      this.callback(event);
      console.log(modeMaster._modes);
      return true;
    }
  }
}

class EventManager {
  MAP = {
    document: {
      keyEvents: {
        keypress: {
          "*": [
            new EventDef([modeMaster.has, "writing", "text"], [], TextLayer.keyDownEvent),
          ],
        },
        keydown: {
          [keyGroup(...ArrowKeyGroup)]: [
            new EventDef([modeMaster.has, "selected"],
                [], (event) => layerManager.selectedArrowKeyDownEvent(event.key)),
          ],
          [["Shift"]]: [
            new EventDef([modeMaster.hasAny],
                [modeMaster.add, "shift"])
          ],
          [keyGroup("Backspace", "Delete")]: [
            new EventDef([modeMaster.has, "selected"],
                [modeMaster.reset, "select"], () => layerManager.deleteLayersEvent()),
          ],
          [keyGroup("Escape")]: [
            new EventDef([modeMaster.hasOr, "writing", "selected"],
                [modeMaster.reset, "select"], () => layerManager.unselectAll()),
          ],
          [keyGroup("Backspace", "Delete", ...ArrowKeyGroup)]: [
            new EventDef([modeMaster.has, "writing", "text"],
                [], TextLayer.keyDownEvent),
          ],
          [keyGroup("Control")]: [
            new EventDef([modeMaster.hasAny],
                [modeMaster.add, "ctrl"]),
          ],
          [keyGroup("Z", "z")]: [
            new EventDef([modeMaster.has, "shift", "ctrl"],
                [], (event) => layerManager.redoEvent(event)),
          ],
          [keyGroup("z")]: [
            new EventDef([modeMaster.has, "ctrl"],
                [], (event) => layerManager.undoEvent(event)),
          ],
          [keyGroup("c")]: [
            new EventDef([modeMaster.has, "ctrl", "selected"],
                [], () => layerManager.copySelectedLayersEvent()),
          ],
          [keyGroup("a")]: [
            new EventDef([modeMaster.has, "ctrl"],
                [modeMaster.reset, "selected"], (event) => layerManager.selectAllEvent(event)),
          ],
          [keyGroup("g")]: [
            new EventDef([modeMaster.has, "selected"],
                [], () => layerManager.groupSelectedLayersEvent()),
          ],
        },
        keyup: {
          [keyGroup("Shift")]: [
            new EventDef([modeMaster.has, "shift"],
                [modeMaster.remove, "shift"]),
          ],
          [keyGroup("Control")]: [
            new EventDef([modeMaster.has, "ctrl"],
                [modeMaster.remove, "ctrl"]),
          ],
        }
      }
    },
    window: {
      mouseEvents: {
        resize: [
          new EventDef([], [], (event) => canvas.scale()),
        ],
        paste: [
          new EventDef([modeMaster.has, "writing", "text"],
          [], (event) => layerManager.pasteToTextLayerEvent(event)),
          new EventDef([],
          [], (event) => layerManager.pasteAsTextLayerEvent(event))
        ],
        mouseup: [
          new EventDef([modeMaster.has, "drawing"],
              [modeMaster.change, "drawing", "draw"], (event) => layerManager.tidyLayersEvent(event)),
          new EventDef([modeMaster.has, "erasing"],
              [modeMaster.change, "erasing", "erase"]),
          new EventDef([modeMaster.has, "moving"],
              [modeMaster.remove, "moving"], (event) => layerManager.tidyLayersEvent(event)),
          new EventDef([modeMaster.has, "area-selecting"],
              [modeMaster.remove, "area-selecting"], (event) => areaSelectManager.areaSelectingMouseUpEvent(event)),
          new EventDef([modeMaster.has, "resizing"],
              [modeMaster.remove, "resizing"], (event) => layerManager.tidyLayersEvent(event)),
        ],
      }
    },
    canvas: {
      mouseEvents: {
        mousedown: [
          new EventDef([modeMaster.has, "draw", "text"],
              [modeMaster.change, "draw", "writing"], TextLayer.drawMouseDownEvent),
          new EventDef([modeMaster.has, "draw"],
              [modeMaster.change, "draw", "drawing"], Layer.drawMouseDownEvent),
          new EventDef([modeMaster.has, "writing", "text"],
              [], TextLayer.writingMouseDownEvent),
          new EventDef([modeMaster.has, "erase"],
              [modeMaster.change, "erase", "erasing"], (event) => layerManager.erasePixelEvent(event)),
          new EventDef([modeMaster.hasOr, "selected", "select"],
              [], Layer.selectMouseDownEvent),
        ],
        mouseover: [
          new EventDef([modeMaster.has, "draw", "line"], // Technically this should be for any joiner layer...
              [], BaseLineLayer.drawMouseOver),
          new EventDef([modeMaster.has, "draw"],
              [], Layer.drawMouseOver),
          new EventDef([modeMaster.has, "drawing"],
              [], Layer.drawingMouseOverEvent),
          new EventDef([modeMaster.has, "erasing"],
              [], (event) => layerManager.erasePixelEvent(event)),
          new EventDef([modeMaster.has, "area-selecting"],
              [], (event) => areaSelectManager.areaSelectingMouseOverEvent(event)),
          new EventDef([modeMaster.has, "moving"],
              [], (event) => layerManager.movingMouseOverEvent(event)),
          new EventDef([modeMaster.has, "resizing"],
              [], (event) => layerManager.resizingMouseOverEvent(event)),
          new EventDef([modeMaster.hasOr, "selected", "select"],
              [], (event) => layerManager.selectMouseOverEvent(event)),
        ],
        dblclick: [
          new EventDef([modeMaster.has, "selected", "text"],
              [modeMaster.change, "selected", "writing"], TextLayer.selectedDoubleClickEvent),
          new EventDef([modeMaster.has, "writing"],
              [], TextLayer.selectedDoubleClickEvent),
        ]
      }
    }
  }

  assignMouseEventDefs(element, allDefs) {
    for (const [eventType, defs] of Object.entries(allDefs)) {
      element.addEventListener(eventType, (event) => {
        for (var def of defs) if (def.run(event)) return;
      })
    }
  }

  assignKeyEventDefs(element, defs) {
    Object.keys(defs).forEach((eventType) => {
      element.addEventListener(eventType, (event) => {
        // This maps apple Command key to Ctrl.
        var eventKey = event.key == "Meta"? "Control": event.key;
        for (var keys in defs[eventType]) {
          for (let key of keys.split(",")) {
            if (key == eventKey || key == "*") {
              for (var def of defs[eventType][keys]) {
                if (def.run(event)) return;
              }
            }
          };
        }
      });
    });
  }

  assignAll(namedElements) {
    for (const [elementName, eventGroups] of Object.entries(this.MAP)) {
      for (const [eventGroup, eventDefs] of Object.entries(eventGroups)) {
        switch (eventGroup) {
          case "mouseEvents":
            this.assignMouseEventDefs(namedElements[elementName], eventDefs);
          break;
          case "keyEvents":
            this.assignKeyEventDefs(namedElements[elementName], eventDefs);
          break;
        }
      }
    }
  }
}


class CharManager {

    // Useful: https://www.w3.org/TR/xml-entity-names/025.html
    // And: https://www.amp-what.com/unicode/search/dot
    charset = {

      // Dotted lines
      "•": ["dotted", "line", "vertical", "lateral", "corner", "generic", "unicode"],
      ".": ["dotted", "line", "vertical", "lateral", "corner", "generic", "ascii"],

      // Solid lines
      "━": ["solid-bold", "line", "lateral", "unicode"],
      "┃": ["solid-bold", "line", "vertical", "unicode"],
      "|": ["solid-thin", "solid-bold", "line", "vertical", "ascii"],
      "─": ["solid-thin", "line", "lateral", "unicode"],
      "│": ["solid-thin", "line", "vertical", "unicode"],
      "\\": ["solid-thin", "solid-bold", "diag-back", "line", "unicode", "ascii"],
      "/": ["solid-thin", "solid-bold", "diag-forward", "line", "unicode", "ascii"],

      // Dashed lines
      "'": ["dashed", "line", "vertical", "ascii"],
      "╶": ["dashed", "line", "lateral", "unicode"],
      "╷": ["dashed", "line", "vertical", "unicode"],
      "-": ["dashed", "solid-bold", "solid-thin", "line", "lateral", "ascii"],

      // Arrows
      "^": ["arrow", "up", "ascii"],
      ">": ["arrow", "right", "ascii"],
      "<": ["arrow", "left", "ascii"],
      "v": ["arrow", "down", "ascii"],
      "▲": ["arrow", "up", "unicode"],
      "▶": ["arrow", "right", "unicode"],
      "◀": ["arrow", "left", "unicode"],
      "▼": ["arrow", "down", "unicode"],

      // Corners
      "┏": ["corner", "solid-bold", "top-left", "unicode"],
      "┓": ["corner", "solid-bold", "top-right", "unicode"],
      "┗": ["corner", "solid-bold", "bottom-left", "unicode"],
      "┛": ["corner", "solid-bold", "bottom-right", "unicode"],

      "┌": ["corner", "dashed", "solid-thin", "top-left", "unicode"],
      "┐": ["corner", "dashed", "solid-thin", "top-right", "unicode"],
      "└": ["corner", "dashed", "solid-thin", "bottom-left", "unicode"],
      "┘": ["corner", "dashed", "solid-thin", "bottom-right", "unicode"],

      "·": ["diamond-corner", "solid-thin", "solid-bold", "vertical", "lateral", "unicode"],

      "+": [
        "corner", "diamond-corner", "lateral", "vertical",
        "solid-bold", "solid-thin", "dashed",
        "ascii", "top-left", "top-right",
        "bottom-left", "bottom-right", "generic"
      ],

      // Misc
      "x": ["free"],
    }

    constructor() {
      this.charsetForm = localStorage.getItem("charset") || "unicode"; // Default to unicode
    }

    getBestChar(...description) {
      var lastMatches = -1;
      var lastChar = null;
      for (let character in this.charset) {
        let tags = this.charset[character];
        let matches = tags.filter(tag => description.includes(tag)).length;
        if (matches > lastMatches) {
          lastMatches = matches;
          lastChar = character;
        }
      }
      return lastChar;
    }

    getCharset() {
      return this.charsetForm;
    }

    setCharset(form) {
      localStorage.setItem("charset", form);
      this.charsetForm = form;
    }

    getDiagBackLine(lineForm) {
      return this.getBestChar("diag-back", "line", lineForm, this.getCharset());
    }

    getDiagForwardLine(lineForm) {
      return this.getBestChar("diag-forward", "line", lineForm, this.getCharset());
    }

    getVerticalLine(lineForm) {
      return this.getBestChar("vertical", "line", lineForm, this.getCharset());
    }

    getLateralLine(lineForm) {
      return this.getBestChar("lateral", "line", lineForm, this.getCharset());
    }

    getCorner(lineForm, position) {
      return this.getBestChar("corner", position, lineForm, this.getCharset());
    }

    getDiamondCorner(lineForm, position) {
      return this.getBestChar("diamond-corner", position, lineForm, this.getCharset());
    }

    getArrow (direction) {
      return this.getBestChar("arrow", direction, this.getCharset());
    }

    getFree() {
      return this.getBestChar("free");
    }
}


class GroupManager {
  constructor() {
    this.layerGroups = [];
    this.layerGroupHistory = [];
  }

  empty() {
    this.layerGroups = [];
    this.layerGroupHistory = [];
  }

  capture() {
    this.layerGroupHistory.unshift(structuredClone(this.layerGroups));
  }

  jumpHistory(cursor) {
    this.layerGroups = this.layerGroupHistory[cursor];
  }

  findGroupsFromLayers(layers) {
    /*
      Find groups which are fully included in the provided layers.
      E.g
      Groups = [[1, 2, 3], [5, 6], [4, 5], [1, 2]]
      layers = [1, 2, 3, 4]
        => [[1, 2, 3], [1, 2]]
    */

    // This means, somehow, we are looking for groups with layers
    // that have been removed.
    if (!layers.every(Boolean)) return [];

    var foundGroups = [];
    let layerIds = layers.map(layer => layer.id);
    for (var groupLayerIds of this.layerGroups) {
      if (groupLayerIds.map(layerId => layerIds.includes(layerId)).every(Boolean)) {
        foundGroups.push(groupLayerIds);
      }
    }
    return foundGroups;
  }

  ungroupLayers(layers) {
    let groups = this.findGroupsFromLayers(layers).map(group => group.toString());
    this.layerGroups = this.layerGroups.filter(group => !groups.includes(group.toString()));
  }

  groupLayers(layers) {
    this.layerGroups.push(layers.map(layer => layer.id));
  }

  getSiblingLayerIds(memberLayer) {
    var layerIds = [];
    for (var group of this.layerGroups) {
      if (group.includes(memberLayer.id)) layerIds = layerIds.concat(group);
    }
    return layerIds;
  }

  tidy(layers) {
    var index = 0;
    for (var layerGroup of this.layerGroups) {
      this.layerGroups[index] = layerGroup.filter(layerId => !layers.includes(layerId));
      index ++;
    }
    // Tidy empty / one layer groups
    this.layerGroups = this.layerGroups.filter(group => group.length > 1);
  }
}


class AreaSelectManager {
  constructor() {
    this.areaSelectionPixels = [];
  }

  clearAreaSelection() {
    this.areaSelectionPixels.forEach(pixel => pixel.renderNormal());
    this.areaSelectionPixels = [];
  }

  areaSelectingMouseUpEvent(event) {
    this.clearAreaSelection();
    // Re-render selected layers having just cleared pixels.
    layerManager.getSelectedLayers().forEach(layer => layer.renderSelected());
  }

  areaSelectingMouseOverEvent(event) {
    this.clearAreaSelection();
    let firstPixel = layerManager.getSelectPixel();

    let activePixel = canvas.getPixelById(event.target.id);
    let lateralDiff = activePixel.col - firstPixel.col;
    let verticalDiff = activePixel.row - firstPixel.row;
    let total = Math.abs(lateralDiff * verticalDiff)

    var drawRow = firstPixel.row;
    var drawCol = firstPixel.col;
    for (var row = 0; row <= Math.abs(verticalDiff); row ++) {
      for (var col = 0; col <= Math.abs(lateralDiff); col ++) {
        let pixel = canvas.getPixelByRowCol(parseInt(drawRow), parseInt(drawCol));
        this.areaSelectionPixels.push(pixel);
        drawCol += lateralDiff / Math.abs(lateralDiff);
      }
      drawRow += verticalDiff / Math.abs(verticalDiff);
      drawCol = firstPixel.col;
    }

    this.selectLayersInAreaSelection();
    this.areaSelectionPixels.forEach(pixel => pixel.renderAreaSelected());
  }

  selectLayersInAreaSelection() {
    let layersToSelect = [];
    for (var layer of layerManager.layers) {
      let layerPixelIds = layer.pixels.map(pixel => pixel.id());
      let selectedPixelIds = this.areaSelectionPixels.map(pixel => pixel.id());
      if (layerPixelIds.filter(pixel => !selectedPixelIds.includes(pixel)).length) {
        if (layer.isSelected()) {
          layer.unselect();
        }
      } else {
        layersToSelect.push(layer);
      }
    }

    if (layersToSelect.length) modeMaster.change("select", "selected");
    for (let layer of layersToSelect) {
      layer.select();
      layerManager.selectGroupsByMemberLayer(layer);
    }
  }
}

class LayerManager {

  LayerRegister = [
    FreeLineLayer,
    FreeLayer,
    StepLineLayer,
    CircleLayer,
    SwitchLineLayer,
    SquareLayer,
    TextLayer,
    TableLayer,
    DiamondLayer,
  ]

  constructor() {
    this.layers = [];
    this.selectedPixel = null;
    this.layerHistory = [[]];
    this.historyCursor = 0;
    this.editingTextLayer = null;
    this.groupManager = new GroupManager();
  }

  getLayerTypes() {
    return this.LayerRegister.map(cls => cls.type);
  }

  getLineBasedLayerTypes() {
    return this.LayerRegister.filter(cls => cls.lineBased).map(cls => cls.type);
  }

  getLayerClassByType(type) {
    for (let cls of this.LayerRegister) {
      if (type == cls.type) return cls;
    }
  }

  add(layer) {
    this.layers.unshift(layer);
  }

  addSecond(layer) {
    this.layers.splice(1, 0, layer);
  }

  getLatestLayer() {
    return this.layers[0];
  }

  hasLayer(layerId) {
    return this.layers.map(layer => layer.id).includes(layerId);
  }

  getLayerById(layerId) {
    for (var layer of this.layers) {
      if (layer.id == layerId) return layer;
    }
  }

  getLayerByPixelId(id) {
    // Descending (reversed)
    for (var layer of this.getLayersOrderedByZindex().reverse()) {
      if (layer.hasPixel(id)) return layer;
    }
  }

  encodeAll() {
    let encodedLayers = this.layers.map(layer => layer.encode());
    let data = {layers: encodedLayers, groups: this.groupManager.layerGroups};
    return JSON.stringify(data);
  }

  decodeLayers(layers) {
    return layers.map(layer => this.getLayerClassByType(layer.ty).decode(layer));
  }

  import(encodedData) {
    this.refresh(() => this.empty());
    let data = JSON.parse(encodedData);
    this.layers = this.decodeLayers(data.layers);
    this.groupManager.layerGroups = data.groups;

    // Why do we redraw twice? Because only once everything
    // is drawn, can the correct draw be fully determined.
    // For example, step line flipping needs to inspect other layers,
    // which can only be done once all drawn.
    this.refresh(() => {
      this.layers.forEach(layer => layer.redraw());
    });
    this.refresh(() => {
      this.layers.forEach(layer => layer.redraw());
    });
  }

  importFromLocalStorage() {
    let data = localStorage.getItem("savedWorkspace");
    if (data && JSON.parse(data).layers.length) this.import(data);
  }

  saveToLocalStorage() {
    localStorage.setItem("savedWorkspace", this.encodeAll());
  }

  getSelectedLayers() {
    return this.layers.filter((layer) => layer.isSelected());
  }

  deleteSelectedLayers() {
    this.getSelectedLayers().forEach((layer) => layer.empty());
    this.tidyLayers();
  }

  selectGroupsByMemberLayer(memberLayer) {
    let siblingLayerIds = this.groupManager.getSiblingLayerIds(memberLayer);
    siblingLayerIds.forEach(layerId => this.getLayerById(layerId).select());
  }


  undo() {
    let limit = this.layerHistory.length - 1;
    this.historyCursor = (this.historyCursor < limit)? this.historyCursor + 1: limit;
    // Copy historic layers to avoid mutating them now that they're current.
    // Past will otherwise show as present...
    this.layers = this.copyReplaceLayers(this.layerHistory[this.historyCursor]);
    this.groupManager.jumpHistory(this.historyCursor);

    // Put latest visuals to local storage (we can't rely on capture as undo should not capture).
    this.saveToLocalStorage();
  }

  redo() {
    this.historyCursor = (this.historyCursor > 0)? this.historyCursor - 1: 0;
    // Copy historic layers to avoid mutating them now that they're current.
    // Past will otherwise show as present...
    this.layers = this.copyReplaceLayers(this.layerHistory[this.historyCursor]);
    this.groupManager.jumpHistory(this.historyCursor);

    // Put latest visuals to local storage (we can't rely on capture as redo should not capture).
    this.saveToLocalStorage();
  }

  copyReplaceLayers(layers) {
    return layers.map(layer => layer.copy(true));
  }

  copyAndRenderSelectedLayers() {
    // Copy layers and create a lookup for old to new. This can be used
    // by various functions to update new layers with appropriate relationships
    // and states (given those of old layers).
    let layerLookup = {};
    let layersToCopy = this.getSelectedLayers();
    for (var layer of layersToCopy) layerLookup[layer.id] = {old: layer, new: layer.copyAndRender()};
    this.moveLayersToAvailableSpace(Object.values(layerLookup).map(oldNewLayer => oldNewLayer.new));

    this.repointJointsForCopiedLayers(layerLookup);
    this.regroupForCopiedLayers(layerLookup);
    this.repointTableTextLayers(layerLookup);
  }

  repointTableTextLayers(layerLookup) {
    // For tables, we must point text layer references to the newly copied text layers.
    // We also ensure new TextLayers point to their new table.
    for (let oldLayerId in layerLookup) {
      let oldLayer = layerLookup[oldLayerId].old;
      let newLayer = layerLookup[oldLayerId].new;
      if (oldLayer.is("table")) {
        for (let cellId in oldLayer.textLayers) {
          let oldTextLayerId = oldLayer.textLayers[cellId];

          // Find the new version of the TextLayer given the old TextLayer ID.
          let newTextLayer = layerLookup[oldTextLayerId].new;

          // Give the new TextLayer it's new table reference.
          newTextLayer.tableId = newLayer.id;

          // Give the TableLayer at the corresponding cell it's new TextLayer reference.
          newLayer.textLayers[cellId] = newTextLayer.id;
        }
      }
    }
  }

  regroupForCopiedLayers(layerLookup) {
    // This groups the newly copied layers which were grouped before being copied.
    let layersToCopy = Object.values(layerLookup).map(oldNewLayer => oldNewLayer.old);
    let groupsToCopy = this.groupManager.findGroupsFromLayers(layersToCopy);
    for (var group of groupsToCopy) {
      var newGroup = group.map(layerId => layerLookup[layerId].new);
      this.groupManager.groupLayers(newGroup);
    }
    this.capture();
  }

  repointJointsForCopiedLayers(layerLookup) {
    // This goes through joints of old layers and updates
    // the joint layers to the newly copied joints if they
    // were included in the copied selection / are in the lookup.
    for (var oldLayerId in layerLookup) {
      let oldNewLayer = layerLookup[oldLayerId];
      for (var joint of oldNewLayer.old.joints) {

        // Find the new version of the joint layer given the old layer ID.
        let jointOldNewLayer = layerLookup[joint.layerId];

        if (jointOldNewLayer) {
          let newJoint = structuredClone(joint);
          newJoint.layerId = jointOldNewLayer.new.id;
          oldNewLayer.new.joints.push(newJoint);
        }
      }
    }
  }

  getNearOverlappingCount(subjectLayer, withNames) {
    /*
    This counts how many pixels from other layers are near
    or overlapping the subjectLayer. withNames can also
    be provided to only worry about specific layer.getType()s
    being near/overlapping. This is mainly used to make decisions
    based on how busy a space is.
    */
    var count = 0;
    for (let layer of this.layers) {
      if (withNames && withNames.includes(layer.getType())) {
        count += layer.getNearOverlappingCount(subjectLayer);
      }
    }
    return count;
  }

  unselectAll() {
    this.layers.forEach(layer => layer.unselect());
    if (this.editingTextLayer) this.editingTextLayer.clearLastCursor();
  }

  switchModeCallback() {
    this.unselectAll();
    this.capture();
  }

  refresh(updateFunc) {
    this.clearAll();
    updateFunc();
    this.renderAll();
  }

  tidyAllJoints(layersToDelete) {
    for (var layer of this.layers) {
      layer.joints = layer.joints.filter(joint => !layersToDelete.includes(joint.layerId));
      layer.tidyJoints();
    }
  }

  deleteLayers() {
    // Find layer IDs for dereferencing
    let layersToDelete = this.layers.filter(layer => !layer.pixels.length).map(layer => layer.id);

    // Delete empty layers
    this.layers = this.layers.filter(layer => !layersToDelete.includes(layer.id));

    // Delete references to empty layers in groups
    this.groupManager.tidy(layersToDelete);

    // Delete references to empty layers in layer joints
    this.tidyAllJoints(layersToDelete);

    // Delete references to empty layers in tables (this really shouldn't be needed),
    // But a user could ungroup a table manually and delete layers.
    this.tidyAllTables(layersToDelete);
  }

  tidyAllTables(layersToDelete) {
    for (let layer of this.layers.filter(layer => layer.is("table"))) {
      for (let key in layer.textLayers) {
        if (layersToDelete.includes(layer.textLayers[key])) delete layer.textLayers[key]
      }
    }
  }

  tidyLayers() {
    this.deleteLayers();
    this.capture();
  }

  clearAll() {
    this.layers.forEach((layer) => layer.clear());
  }

  getLayersOrderedByZindex() {
    // Ascending
    return this.layers.slice().sort((a, b) => a.zindex - b.zindex);
  }

  renderAll() {
    this.getLayersOrderedByZindex().forEach((layer) => layer.render());
  }

  layerPixelIsVisible(targetLayer, targetPixel) {
    // This checks if the value of a layer at a specific pixel is actually showing.
    // Otherwise, another layer using the same pixel is showing it's value in front.
    // Note, joint pixels make this method annoyingly complicated...

    // Descending
    for (let layer of this.getLayersOrderedByZindex().reverse()) {
      // If the pixel is either part of the layer, or used as a joint pixel by the layer.
      let isUsingPixel = layer.usesPixel(targetPixel.id());
      let isTargetLayer = layer.id == targetLayer.id;

      // We need to determine if layer and targetLayer are 'connected' at the target pixel,
      // regardless of if a joint has been created yet.
      let isConnectedToTargetLayer = (
        layer.hasJoinerPixel(targetPixel.id()) ||
        layer.hasJointPixel(targetPixel.id())
      );
      // If the first layer to have the target pixel is the target layer, it's visible.
      // IsUsingPixel check here isn't really needed as targetLayer should always use targetPixel,
      // nonetheless it makes more sense in case the provided target layer/pixel is wrong.
      if (isTargetLayer && isUsingPixel) return true;

      // If the first layer to have the target pixel is another layer,
      // and that layer isn't connected to the target layer, it's not visible.
      // If they are connected, we don't want them to hide each other because:
      //  - Other layers may want to see and probe the joint pixel
      //    (joiner pixel should not hide the joint pixel).
      //  - A joint will never actually be possible.
      //    (joiner pixel should not hide the joint pixel, otherwise it'll never make a joint!).
      //  - Joint pixels aren't always on the layer, and are therefore 'transparent'
      //    (joint pixels alone shouldn't hide joiner pixels).
      if (!isTargetLayer && isUsingPixel && !isConnectedToTargetLayer) return false;
    }

    // There is no obvious case we should arrive here, unless the targetLayer somehow
    // doesn't use the targetPixel.
    return false;
  }

  empty() {
    this.layers = [];
    this.layerHistory = [];
    this.groupManager.empty();
    this.capture();
  }

  capture() {
    // This is used to record history for undo/redo state.
    this.historyCursor = 0;
    this.layerHistory.unshift(this.copyReplaceLayers(this.layers));
    this.groupManager.capture();

    // We also save latest changes to local storage.
    this.saveToLocalStorage();
  }

  setSelectPixel(selectedPixel) {
    this.selectedPixel = selectedPixel;
  }

  getSelectPixel() {
    return this.selectedPixel;
  }

  atomicCommit(...jobs) {
    let committedLayers = [];
    for (let [layer, func] of jobs) {
      let committed = layer.commit(() => func(layer));
      if (!committed) {
        // If a the layer failed to move, then rollback the others that did move.
        committedLayers.forEach(layer => layer.rollback());
        return;
      }
      committedLayers.push(layer);
    }
    return true;
  }

  moveLayersAtomically(layers, verticalDiff, lateralDiff) {
    // If multiple layers are selected, they should all move
    // together to avoid breaking joints. If one layer hits
    // the canvas boundary, none should move. Hence, here
    // we ensure all moves are doable before keeping them.
    let success = this.atomicCommit(
      ...layers.map(layer => [layer, () => layer.move(verticalDiff, lateralDiff)])
    );
    if (!success) return;

    // If we are here, all layers have moved, so we can now resize
    // their joiner layers.

    // resizeSelectedJoinerLayers is false here because moving
    // them takes priority, and doing both is error prone. They will move
    // with their joint layer anyway, meaning the joint is persisted.
    // Otherwise, the joiner layer could unjoin because it's moved
    // twice, from the main move routine and the resize joiner layer routine.
    for (let layer of layers) layer.resizeJoinerLayers(false);
    return true;
  }


  moveSelectedLayers(verticalDiff, lateralDiff) {
    let selectedLayers = this.getSelectedLayers();
    this.refresh(() => this.moveLayersAtomically(selectedLayers, verticalDiff, lateralDiff));
    this.findJoints(selectedLayers);
  }

  moveLayersToAvailableSpace(layers) {
    let directions = [[1, 1], [-1, 1], [1, -1], [-1, -1]];
    for (let direction of directions) {
      if(this.moveLayersAtomically(layers, ...direction)) return true;
    }
    return false;
  }

  findJoints(changedLayers) {
    for (var layer of this.layers) {
      if (layer.isSelected()) continue;
      // Only joinable layers will return joint pixels here and therefore get probed.
      let keyedJoints = layer.getKeyedJointPixels();
      for (let jointKey in keyedJoints) {
        let jointPixel = keyedJoints[jointKey];
        var renderState = -1;
        for (var probingLayer of changedLayers) {
          if (probingLayer.id == layer.id) continue;
          // Only prober layers will look for joins (e.g lines).
          let state = probingLayer.probeJoint(layer, jointKey, jointPixel);
          if (state > renderState) renderState = state;
        }
        switch (renderState) {
          case 0:
            jointPixel.renderWasSelected();
          break;
          case 1:
            jointPixel.renderJointNear();
          break;
          case 2:
            jointPixel.renderJoint();
          break;
        }
      }
    }
  }

  getJoinersFromLayers(layers) {
    var layerIds = [];
    for (var layer of layers) {
      for (var joint of layer.joints) {
        layerIds.push(joint.layerId);
      }
    }
    return layerIds;
  }

  prepareLayerResizing(activePixel, leadLayer) {
    let resizePixelIndex = leadLayer.getResizePixelIndex(activePixel);
    if (resizePixelIndex == -1) return false;
    for (var resizeLayer of this.getSelectedLayers()) {
      if (!resizeLayer.isResizable()) continue;
      var resizePixel;
      if (resizeLayer.id == leadLayer.id) {
        // If the selected layer is the lead / currently selected layer
        // Then we already know the activePixel is the resize pixel.
        resizePixel = activePixel;
      } else if (resizeLayer.getType() == leadLayer.getType() && !leadLayer.isLine()) {
        // If the lead layer is the same type as a selected layer,
        // we can use the same resize pixel position and resize the layer
        // in the same way for the best experience.

        // Lines are excluded because resize positions are subjective to the line
        // depending on where it was drawn from. Using the "nearest" logic is better.
        resizePixel = resizeLayer.getResizePixels()[resizePixelIndex];
      } else {
        // Otherwise, we find the layer's nearest resize pixel and
        // resize from there.
        resizePixel = resizeLayer.getNearestResizePixel(activePixel);
      }
      // The "to" pixel has been determined above depending on various rules.
      resizeLayer.setToPixel(resizePixel);

      // The resize "from" pixel is the opposite to the active "to" resize pixel
      // determined above. We set it here as the from pixel to mimic
      // the act of drawing it from the first pixel selected.
      let fromResizePixel = resizeLayer.getResizeOppositePixel(resizePixel);
      resizeLayer.setFromPixel(fromResizePixel);
    }
    return true;
  }

  renderCharset() {
    for (let layer of this.layers) layer.redrawChars(layer.lineForm);
  }

  // Generic multi-layer based events...

  resizingMouseOverEvent(event) {
    let activePixel = canvas.getPixelById(event.target.id);
    let layers = this.getSelectedLayers();
    this.refresh(() => this.resizeLayers(layers, activePixel));
    this.findJoints(layers);
  }

  resizeLayers(layers, activePixel) {
    let selectPixel = this.getSelectPixel();
    let verticalDiff = activePixel.row - selectPixel.row;
    let lateralDiff = activePixel.col - selectPixel.col;
    let joinerLayers = this.getJoinersFromLayers(layers);

    for (var layer of layers) {
      // Selected layers that are joiners to another selected layer should not
      // get resized, as the joint will handle moving it correctly.
      // Otherwise, the resize is at risk of unexpectly unjoining the layers
      // in question.
      if (joinerLayers.includes(layer.id)) continue;

      // If the layer belongs to a table, resizing should never happen
      // as resizing tables is used to add/remove columns, not move child
      // layers around.
      if (layer.hasTable()) continue;
      if (!layer.isResizable()) {
        // If the layer is not resizable, the best thing we can do is move it.
        if (layer.commit(() => layer.move(verticalDiff, lateralDiff))) layer.resizeJoinerLayers(true);
        continue;
      }
      /*
      layer.fromPixel: The "from" pixel for a specific layer (where it should be drawn from)
      layer.toPixel: The pixel the layer should draw to
      selectPixel: The previous activePixel to determine the diff with current activePixel.
                   This pixel starts as wherever the user first pressed.
      activePixel: The actual current pixel of the mouse.

      layer.fromPixel
          ._________
          *        |
          |        |
          |        |       *.. selectedPixel
          |        |        \
          |        |         \ .. vertical/lateralDiff
          |________*          \
                   .\           * .. activePixel
                   . \
                   .  \
                   .   * .. layer.toPixel + vertical/lateralDiff
                   .
                layer.toPixel

      With both of these determined, the layer can be resized.
      */

      // For this layer, the resize pixel is out of bounds.

      let toPixel = canvas.getPixelByRowCol(
        layer.toPixel.row + verticalDiff, layer.toPixel.col + lateralDiff
      );
      if (!toPixel) continue;

      // resizeSelectedJoinerLayers is true because layers are changing
      // and selected joiner layers should favour maintaining joints and resizing
      // that way, instead of resizing independently.
      layer.draw(toPixel.id(), true);
    }
    // Note we set selectPixel to activePixel so that the next iteration
    // can diff the new activePixel to this one.
    this.setSelectPixel(activePixel);
  }

  movingMouseOverEvent(event) {
    let activePixel = canvas.getPixelById(event.target.id);
    let lastPixelSelected = this.getSelectPixel();
    let verticalDiff = activePixel.row - lastPixelSelected.row;
    let lateralDiff = activePixel.col - lastPixelSelected.col;
    this.moveSelectedLayers(verticalDiff, lateralDiff);
    this.setSelectPixel(activePixel);
  }

  selectedArrowKeyDownEvent(key) {
    var verticalDiff = 0;
    var lateralDiff = 0;
    switch (key) {
      case "ArrowUp":
        verticalDiff = -1;
        break;
      case "ArrowRight":
        lateralDiff = 1;
        break;
      case "ArrowDown":
        verticalDiff = 1;
        break;
      case "ArrowLeft":
        lateralDiff = -1;
        break;
    }
    this.moveSelectedLayers(verticalDiff, lateralDiff);
    this.capture();
  }

  deleteLayersEvent(event) {
    this.refresh(() => this.deleteSelectedLayers());
  }

  copySelectedLayersEvent(event) {
    this.refresh(() => this.copyAndRenderSelectedLayers());
  }

  tidyLayersEvent(event) {
    this.tidyLayers();
  }

  selectMouseOverEvent(event) {
    let activePixel = canvas.getPixelById(event.target.id);
    let layerOver = layerManager.getLayerByPixelId(activePixel.id());
    layerOver ? canvas.setCursor("pointer"): canvas.setCursor("default");
    // Ascending
    for (let layer of this.getLayersOrderedByZindex()) {
      for (var resizePixel of layer.getResizePixels()) {
        if (
          (layer.isSelected() ||
          activePixel.isNear(resizePixel)) &&
          this.layerPixelIsVisible(layer, resizePixel)
        ) {
          resizePixel.renderResizable();
        } else {
          resizePixel.renderWasSelected();
        }
      }
    }
  }

  undoEvent(event) {
    this.refresh(() => this.undo());
  }

  redoEvent(event) {
    this.refresh(() => this.redo());
  }

  groupSelectedLayersEvent(event) {
    this.groupManager.groupLayers(this.getSelectedLayers());
    bodyComponent.informerComponent.report("Successfully grouped", "good");
  }

  ungroupSelectedLayersEvent(event) {
    this.groupManager.ungroupLayers(this.getSelectedLayers());
    layerManager.unselectAll();
    modeMaster.reset("select");
    bodyComponent.informerComponent.report("Successfully ungrouped", "good");
  }

  redrawLinesEvent(direction) {
    for (var layer of this.getSelectedLayers()) {
      if (layer.getType().includes("line")) {
        this.refresh(() => layer.toggleArrows(direction));
      }
    }
  }

  redrawLineBasedEvent(lineForm) {
    for (var layer of this.getSelectedLayers()) {
      if (layer.isLineBased()) this.refresh(() => layer.redrawChars(lineForm));
    }
  }

  selectAllEvent(event) {
    event.preventDefault();
    this.layers.forEach(layer => layer.select());
  }

  erasePixelEvent(event) {
    let activePixel = canvas.getPixelById(event.target.id);
    let layer = this.getLayerByPixelId(activePixel.id());
    if (layer && !layer.is("free")) {
      bodyComponent.informerComponent.report("Can only erase free drawings!", "bad");
      return;
    }
    if (layer) this.refresh(() => layer.erasePixel(activePixel.id()));
    activePixel.clear();
  }

  getHighestZindex() {
    // This ensures the first ever layer is set to 0 given that
    // layers use this method during initialization to determine
    // the next zindex needed.
    if (this.layers.length == 0) return 0;

    return Math.max(...this.getZindexes());
  }

  getZindexes() {
    return this.layers.map(layer => layer.zindex);
  }

  getLowestZindex() {
    return Math.min(...this.layers.map(layer => layer.zindex));
  }

  bringForwardEvent(event) {
    let highestZindex = this.getHighestZindex();
    this.refresh(() => this.getSelectedLayers().forEach(layer =>  layer.zindex ++));
    this.tidyLayers();
  }

  sendBackwardsEvent(event) {
    let lowestZindex = this.getLowestZindex();
    this.refresh(() => this.getSelectedLayers().forEach(layer => layer.zindex --));
    this.tidyLayers();
  }

  bringToFrontEvent(event) {
    let highestZindex = this.getHighestZindex();
    this.refresh(() => this.getSelectedLayers().forEach(layer => layer.zindex = highestZindex + 1));
    this.tidyLayers();
  }

  sendToBackEvent(event) {
    let lowestZindex = this.getLowestZindex();
    this.refresh(() => this.getSelectedLayers().forEach(layer => layer.zindex = lowestZindex - 1));
    this.tidyLayers();
  }

  pasteToTextLayerEvent(event) {
    event.stopPropagation();
    event.preventDefault();
    let clipboardData = event.clipboardData || window.clipboardData;
    let text = clipboardData.getData('Text').substring(0, 100);
    this.refresh(
      () => this.editingTextLayer.commit(
        () => this.editingTextLayer.paste(text)
        // TODO: Show error when failing to copy
      )
    );
  }

  pasteAsTextLayerEvent(event) {
    event.stopPropagation();
    event.preventDefault();
    // TODO: Consider unifying clipboard reading with method above
    modeMaster.reset("select");
    let clipboardData = event.clipboardData || window.clipboardData;
    let text = clipboardData.getData('Text').substring(0, 1000);
    let textLayer = new TextLayer(canvas.getPixelByRowCol(30, 30).id());
    textLayer.contents = text.split("");
    layerManager.add(textLayer);
    this.refresh(() => {
      if (textLayer.commit(() => textLayer.drawLayer())) {
        textLayer.select();
      } // TODO: Show error when failing to copy
    });

  }
}


///////////////////
///// LAYERS //////
///////////////////

class Layer {
  static type = "base";
  static lineBased = false;
  static line = false;

  getType() {
    return this.constructor.type;
  }

  isLineBased() {
    return this.constructor.lineBased;
  }

  isLine() {
    return this.constructor.line;
  }

  is(layerType) {
    return this.getType() == layerType;
  }

  constructor(firstPixelId) {
    this.setAllChars("solid-thin");
    this.id = this.makeId();
    this.pixels = [];
    this.values = [];
    this.joints = [];
    this.zindex = layerManager.getHighestZindex() + 1;
    this._isSelected = false;
    this.commitMutex = false;
    this.setFromPixel(canvas.getPixelById(firstPixelId));
    this.setToPixel(null);
    this.stashed = {};
  }


  setAllChars(lineForm) {
    this.lineForm = lineForm;
    this.lateralChar = charManager.getLateralLine(this.lineForm);
    this.verticalChar = charManager.getVerticalLine(this.lineForm);
    this.diagBackChar = charManager.getDiagBackLine(this.lineForm);
    this.diagForwardChar = charManager.getDiagForwardLine(this.lineForm);
    this.cornerTopLeftChar = charManager.getCorner(this.lineForm, "top-left");
    this.cornerTopRightChar = charManager.getCorner(this.lineForm, "top-right");
    this.cornerBottomLeftChar = charManager.getCorner(this.lineForm, "bottom-left");
    this.cornerBottomRightChar = charManager.getCorner(this.lineForm, "bottom-right");
    this.cornerDiamondVerticalChar = charManager.getDiamondCorner(this.lineForm, "vertical");
    this.cornerDiamondLateralChar = charManager.getDiamondCorner(this.lineForm, "lateral");
    this.cornerGenericChar = charManager.getCorner(this.lineForm, "generic");
    this.arrowUpChar    = charManager.getArrow("up");
    this.arrowDownChar  = charManager.getArrow("down");
    this.arrowLeftChar  = charManager.getArrow("left");
    this.arrowRightChar = charManager.getArrow("right");
  }

  static decode(encodedLayer) {
    let layerClass = layerManager.getLayerClassByType(encodedLayer.ty);
    let layer = new layerClass(encodedLayer.fp);
    layer.id = encodedLayer.id;
    layer.setToPixel(canvas.getPixelById(encodedLayer.tp));
    layer.zindex = encodedLayer.zi;
    layer.setAllChars(encodedLayer.lf);
    layer.joints = encodedLayer.jts;
    return layer;
  }

  encode() {
    return {
      ty: this.getType(),
      id: this.id,
      fp: this.fromPixel.id(),
      tp: this.toPixel.id(),
      zi: this.zindex,
      lf: this.lineForm,
      jts: this.joints,
    };
  }

  redrawChars(lineForm) {
    this.setAllChars(lineForm);
    this.redraw();
  }

  makeId() {
    return randomInt(1, 10000000).toString();
  }

  static drawToSelectMouseDownEvent(event) {
    // Just a little side hussle to auto-switch to selecting
    // if drawing but an existing layer was touched.
    let activePixel = canvas.getPixelById(event.target.id);
    let selectLayer = layerManager.getLayerByPixelId(activePixel.id());
    if (
      selectLayer
      && !selectLayer.hasJointPixel(activePixel.id())
      && !selectLayer.hasJoinerPixel(activePixel.id())
    ) {
      modeMaster.reset("select");
      Layer.selectMouseDownEvent(event);
      return true;
    }
    return false;
  }

  static drawMouseDownEvent(event) {
    if (Layer.drawToSelectMouseDownEvent(event)) return;
    // Otherwise we go ahead and create a new layer.
    let layerType = modeMaster.getLayerType();
    let layerClass = layerManager.getLayerClassByType(layerType);
    let layer = new layerClass(event.target.id);
    layerManager.add(layer);
    layerManager.refresh(() => layer.draw(event.target.id));
  }

  static drawingMouseOverEvent(event) {
    let layer = layerManager.getLatestLayer();
    layerManager.refresh(() => layer.draw(event.target.id));
    layerManager.findJoints([layer]);
  }

  static drawMouseOver() {
    let activePixel = canvas.getPixelById(event.target.id);
    let layerOver = layerManager.getLayerByPixelId(activePixel.id());
    if (modeMaster.has("text") && (!layerOver || layerOver.is("text"))) {
      canvas.setCursor("text");
    } else if (layerOver) {
      canvas.setCursor("pointer");
    } else {
      canvas.setCursor("crosshair");
    }
  }

  static selectMouseDownEvent(event) {
    let activePixel = canvas.getPixelById(event.target.id);
    let layer = layerManager.getLayerByPixelId(activePixel.id());
    let selectedLayers = layerManager.getSelectedLayers();

    layerManager.setSelectPixel(activePixel);
    // Unselect all if...
    // 1. clicked-off (no layer selected)
    // 2. Single select mode (not multi) and alternative layer picked.
    if (!layer || (!modeMaster.has("shift") && !layer.isSelected())) {
      layerManager.unselectAll();
      modeMaster.change("selected", "select");
    }
    if (!layer) {
      modeMaster.add("area-selecting");
      return;
    }
    layerManager.refresh(() => layer.select());
    modeMaster.change("select", "selected");
    modeMaster.setSelectedLayerMode(layer);
    modeMaster.add(
      layerManager.prepareLayerResizing(activePixel, layer)? "resizing": "moving"
    );
    if (!modeMaster.has("shift") || layer.is("table") || layer.hasTable()) {
      // Select all members of a group if not bypassed by ctrl to select a grouped
      // layer.
      // This bypass shouldn't work for tables / table children to avoid undefined behaviour.
      layerManager.refresh(() => layerManager.selectGroupsByMemberLayer(layer));
    }
  }

  draw(activePixelId) {
    let committed = this.commit(() => this.drawLayer(activePixelId));
    if (committed && this.isJoinable()) this.resizeJoinerLayers(true);
  }

  isHappy() {
    // Anything that doesn't satisfy this condition will cause a rollback.
    // Currently, it just ensures pixels are valid, but it could be anything,
    // and extending this in specific layers is welcomed.
    return Boolean(
      this.pixels.every(Boolean)
      && this.getJointPixels().every(Boolean)
      && this.fromPixel
      && this.toPixel
    );
  }

  commit(...updateFuncs) {
    // Committing is used to trial ANY state changes of a layer.
    // The draw/move functions might recommend pixels that are out of bounds,
    // or in whatever way invalid. If the committed change (updateFuncs)
    // results in an 'unhappy' state, we rollback to the stashed state.

    // If a commit hasn't already started, we start one
    // by stashing the layer's current state.
    // Multiple commits can be applied, but only the first
    // between renders should be stashed.
    if (!this.isCommitting()) this.stash();

    this.beginCommit();

    // Take note of current joint pixels before a change
    // so that joiner layers can be found before they are potentially changed.
    this.lastKeyedJointPixels = this.getKeyedJointPixels();

    // Attempted  the requested changes
    updateFuncs.forEach(func => func());

    let isHappy = this.isHappy();

    // If the changes have caused an upset, rollback to previous state.
    if (!isHappy) this.rollback();

    // Inform the requester of the success of the change.
    return isHappy;
  }

  isCommitting() {
    return this.commitMutex;
  }

  beginCommit() {
    this.commitMutex = true;
  }

  releaseCommit() {
    this.commitMutex = false;
  }

  stash() {
    // This is used to store / remember a layer's state in case a layer becomes unhappy.
    this.stashed = {};
    this.stashed.fromPixel = this.fromPixel;
    this.stashed.toPixel   = this.toPixel;
    this.stashed.pixels    = this.pixels.map(p => p);
    this.stashed.values    = this.values.map(v => v);
  }

  rollback() {
    // This puts a layer back into it's last working state.

    // We can therefore lift the commit mutex, so that future commits
    // stash happy states again.
    this.releaseCommit();

    // The actual rollback...
    this.fromPixel = this.stashed.fromPixel;
    this.toPixel   = this.stashed.toPixel;
    this.pixels    = this.stashed.pixels;
    this.values    = this.stashed.values;
  }

  redraw() {
    this.drawLayer(this.toPixel.id(), true);
    layerManager.capture();
  }

  select() {
    this._isSelected = true;
    this.renderSelected();
    if (layerManager.getSelectedLayers().length > 1) modeMaster.add("multi-select");
  }

  unselect() {
    this._isSelected = false;
    this.renderUnselected();
    if (layerManager.getSelectedLayers().length <= 1) modeMaster.remove("multi-select");
  }

  setToPixel(pixel) {
    this.toPixel = pixel;
  }

  setFromPixel(pixel) {
    this.fromPixel = pixel;
  }

  getLastPixel() {
    return (this.pixels.length)? this.pixels[this.pixels.length - 1]: this.fromPixel;
  }

  getMiddlePixel() {
    return (this.pixels.length)? this.pixels[roundHalf(this.pixels.length / 2)]: this.fromPixel;
  }

  getFirstPixel() {
    return (this.pixels.length)? this.pixels[0]: this.fromPixel;
  }

  add(pixel, value) {
    if (!pixel) return;
    this.pixels.push(pixel);
    this.values.push(value);
    if (this.pixels.length != this.values.length) {
      debugError(`layer pixel/value mismatch: ${this.pixels} != ${this.values}`)
    }
  }

  getJointPixels() {
    return Object.values(this.getKeyedJointPixels());
  }

  // Implement if the shape can be joined to - a "joint" layer.
  // The keys should meaningful reflect the same part of a layer.
  // E.g the key "tl" should always represent the top left
  // corner pixel of a square.
  getKeyedJointPixels() {
    return {};
  }

  // Implement if the layer can join to another (e.g a line - a "joiner" layer)
  getJoinerPixels() {
    return [];
  }

  // Implement if the layer can be resized.
  // This will determine which pixels can be used to
  // resize a layer.
  getResizePixels() {
    return [];
  }

  // Implement if the layer can be resized.
  // This will determine which pixel to resize from,
  // given a resize point.
  getResizeOppositePixel() {
    return false;
  }

  hasTable() {
    return Boolean(this.tableId);
  }

  getTable() {
    return layerManager.getLayerById(this.tableId);
  }

  isResizable() {
    return Boolean(this.getResizePixels().length);
  }

  isJoinable() {
    return Boolean(this.getJointPixels().length);
  }

  isJoiner() {
    return Boolean(this.getJoinerPixels().length);
  }

  getNearestResizePixel(pixel) {
    return pixel.isNearestTo(this.getResizePixels());
  }

  getResizePixelIndex(targetPixel) {
    return this.getResizePixels().map(pixel => pixel.id()).indexOf(targetPixel.id());
  }

  hasJoinerPixel(pixelId) {
    return this.getJoinerPixels().map(pixel => pixel.id()).includes(pixelId);
  }

  hasJointPixel(pixelId) {
    return this.getJointPixels().map(pixel => pixel.id()).includes(pixelId);
  }

  clear() {
    this.pixels.forEach((pixel) => pixel.clear());
  }

  tidyJoints() {
    // TODO consider requirement here
    let keyedJoints = this.getKeyedJointPixels();
    for (let joint of this.joints) {
      let layer = layerManager.getLayerById(joint.layerId);
      if (layer) {
        let jointPixel = keyedJoints[joint.jointKey];
        if (jointPixel) {
          // If the joint of this.layer matches the joiner pixels of the joiner layer (if connected)
          if (layer.getJoinerPixels().map(pixel => pixel.id()).includes(jointPixel.id())) {
            continue;
          } else {
            // This should not happen.
            // Case 1 - When a joint "steals" another joint. This is fine.
            debugError("had to unjoin dangling join: somehow disconnected");
          }
        } else {
          // This should not happen.
          // Case 1 - originally for tables only but they get unjoined now (when rows/cols are removed).
          debugError("had to unjoin dangling join: joint pixel gone");
        }
      } else {
        // This should not happen because joints get deleted when layers do.
        debugError("had to unjoin dangling join: joiner layer gone");
      }
      this.unjoin(joint.layerId, joint.jointKey);
    }
  }

  copy(identical=false) {
    let layerCopy = new this.constructor(this.fromPixel.id());
    if (identical) {
      // This is an exact copy, mainly used for capturing snapshots,
      // reverting history.
      // We only copy joints here, as other use cases need to manually
      // repoint joints to new layers.
      layerCopy.joints = this.joints.map(joint => structuredClone(joint));
      layerCopy.id = this.id;
      layerCopy.zindex = this.zindex;
    } else {
      // By default, a copied layer should appear infront of it's original.
      layerCopy.zindex = this.zindex + 1;
    }
    layerCopy.setFromPixel(this.fromPixel);
    layerCopy.setToPixel(this.toPixel);
    layerCopy.pixels = this.pixels.map(pixel => pixel);
    layerCopy.values = this.values.map(value => value);
    return layerCopy;
  }

  copyAndRender() {
    let layerCopy = this.copy();
    layerManager.add(layerCopy);
    this.unselect();
    layerCopy.select();
    return layerCopy;
  }

  getNearOverlappingCount(targetLayer) {
    // Gets the amount of pixels which are common / the same (the amount of overlap).
    // Or, nearly the same by 1 pixel in any direction.
    var total = 0;
    if (targetLayer.id == this.id) return 0;
    let layerPixelIds = this.pixels.map(pixel => pixel.id());
    let directions = [[0, 0], [1, 1], [-1, 1], [1, -1], [-1, -1]];
    for (let direction of directions) {
      total += targetLayer.getMove(...direction).filter(
        pixel => pixel && layerPixelIds.includes(pixel.id())
      ).length
    }
    return total;
  }

  renderUnselected() {
    this.getJointPixels().forEach(pixel => pixel.renderWasSelected());
    this.pixels.forEach((pixel) => pixel.renderUnselected());
  }

  renderSelected() {
    // Don't show joint pixels if the layer is selected.
    this.getJointPixels().forEach(pixel => pixel.renderWasSelected());
    this.pixels.forEach(pixel => pixel.renderSelected());
    this.getResizePixels().forEach(pixel => pixel.renderResizable());
  }

  render() {
    this.releaseCommit();
    (this.isSelected()) ? this.renderSelected(): this.renderUnselected();
    for (var i = 0; i < this.pixels.length; i++) this.pixels[i].setValue(this.values[i]);
  }

  getMove(verticalDiff, lateralDiff) {
    return this.pixels.map(
      pixel => canvas.getPixelByRowCol(pixel.row + verticalDiff, pixel.col + lateralDiff)
    );
  }

  move(verticalDiff, lateralDiff) {
    this.pixels = this.getMove(verticalDiff, lateralDiff);
    // We must update the to/from pixels so that redraws happen at the new position.
    this.setFromPixel(
      canvas.getPixelByRowCol(this.fromPixel.row + verticalDiff, this.fromPixel.col + lateralDiff)
    );
    this.setToPixel(
      canvas.getPixelByRowCol(this.toPixel.row + verticalDiff, this.toPixel.col + lateralDiff)
    );
  }

  resizeJoinerLayers(resizeSelectedJoinerLayers=false) {
    // resizeSelectedJoinerLayers is used to determine what to do with a probe
    // joint layer if it's selected (as well as the main layer it's joint to).
    // Generally, it should resize as normal. However, if both layers are being
    // moved, moving should take precedence.

    // Only joint layers will have joints.
    for (let joint of this.joints) {
      let layer = layerManager.getLayerById(joint.layerId);

      // Depending on multi-select and the action being taken,
      // it effects if a selected probe join layer should be redrawn.
      // Moved layers don't need to, where as resized layers do.
      if (!layer || (!resizeSelectedJoinerLayers && layer.isSelected())) continue;

      let beforeJointPixel = this.lastKeyedJointPixels[joint.jointKey];
      let currentJointPixel = this.getKeyedJointPixels()[joint.jointKey];

      if (!currentJointPixel) {
        // This means the layer has changed in such a way that the joint pixel
        // is no longer available. It will get unjoined. This only should happen
        // with tables.
        debugError("joint pixel not found");
        this.unjoin(joint.layerId, joint.jointKey);
        return;
      }

      // Get the "from" pixel given the joint pixel before the main layer was moved.
      // We have to use the before JointPixel as the joint layer hasn't moved yet,
      // so that's where it's joining pixel still is.
      let fromPixel = layer.getResizeOppositePixel(beforeJointPixel);

      // The resize pixel may not get found if the main layer has
      // somehow moved without the jointed layer.
      if (!fromPixel) {
        debugError("resize pixel not found");
        return;
      }
      layer.setFromPixel(fromPixel);
      layer.draw(currentJointPixel.id());
    }
  }

  probeJoint(layer, jointKey, jointPixel) {
    let joinerPixels = this.getJoinerPixels();
    if (!joinerPixels.length) return;
    let visible = layerManager.layerPixelIsVisible(layer, jointPixel);
    var state = 0;
    for (var probePixel of joinerPixels) {
      if (visible && probePixel.isNear(jointPixel)) {
        state = 1;
        if (probePixel.is(jointPixel)) {
          state = 2;
          layer.join(this.id, jointKey);
          // Break to avoid unjoining in the following iteration.
          // Only one joiner/probe pixel of the same layer can join to the same jointPixel.
          break;
        }
      }
      layer.unjoin(this.id, jointKey);
    }
    return state;
  }

  join(layerId, jointKey) {
    for (var joint of this.joints) {
      if (layerId == joint.layerId && jointKey == joint.jointKey) {
        return;
      }
    }
    this.joints.push({layerId: layerId, jointKey: jointKey});
  }

  unjoin(layerId, jointKey) {
    var index = 0;
    for (var joint of this.joints) {
      if (layerId == joint.layerId && jointKey == joint.jointKey) {
        this.joints.splice(index, 1);
        return;
      }
      index ++;
    }
  }

  hasPixel(id) {
    return this.getPixelIndex(id) > -1;
  }

  usesPixel(id) {
    return this.hasPixel(id) || this.hasJointPixel(id);
  }

  getPixelIndex(id) {
    for (var i = 0; i < this.pixels.length; i++) {
      let pixel = this.pixels[i];
      if (pixel.id() == id) return i;
    }
    return -1;
  }

  erasePixel(id) {
    for (var i = 0; i < this.pixels.length; i++) {
      if (this.pixels[i].id() == id) this.deletePixelByPosition(i);
    }
  }

  deletePixelByPosition(index) {
    this.pixels.splice(index, 1);
    this.values.splice(index, 1);
  }

  isSelected() {
    return this._isSelected;
  }

  empty() {
    this.pixels = [];
    this.values = [];
  }

  getMinMaxRowsCols() {
    var [maxCol, minCol, maxRow, minRow] = [-1, -1, -1, -1];
    for (var pixel of this.pixels) {
      if (pixel.col > maxCol) maxCol = pixel.col;
      if (pixel.col < minCol || minCol == -1) minCol = pixel.col;
      if (pixel.row > maxRow) maxRow = pixel.row;
      if (pixel.row < minRow || minRow == -1) minRow = pixel.row;
    }
    return [maxCol, minCol, maxRow, minRow];
  }
}


class TextLayer extends Layer {

  static type = "text";

  starterChar = ">";

  constructor(firstPixelId, tableId=null) {
    super(firstPixelId);
    this.contents = [];
    this.cursor = 0;
    this.tableId = tableId;
    if (tableId) this.zindex = layerManager.getLayerById(tableId).zindex;
    this.setToPixel(this.fromPixel);

    // TextLayer's don't use toPixels, but it's easier to just set it.
  }

  static decode(encodedLayer) {
    let layer = Layer.decode(encodedLayer);
    layer.contents = encodedLayer.cts.split("");
    if (encodedLayer.tbl) layer.tableId = encodedLayer.tbl;
    return layer;
  }

  encode() {
    let encoded = super.encode();
    encoded.cts = this.contents.join("");
    if (this.tableId) encoded.tbl = this.tableId;
    return encoded;
  }

  static selectedDoubleClickEvent(event) {
    let activePixel = canvas.getPixelById(event.target.id);
    let layer = layerManager.getLayerByPixelId(activePixel.id());
    layerManager.editingTextLayer = layer;
    layer.moveCursorToPixel(activePixel);
  }

  static drawMouseDownEvent(event) {
    if (Layer.drawToSelectMouseDownEvent(event)) return;
    let activePixel = canvas.getPixelById(event.target.id);
    if (!TextLayer.focusedOtherTextLayer(activePixel)) {
      let layer = new TextLayer(event.target.id);
      layerManager.add(layer);
      layerManager.editingTextLayer = layer;
      layer.setStarterChar();
      layerManager.refresh(() => layer.drawLayer());
      // Give an instant cursor position so it can be cleared
      // even if no writing was done.
      layer.lastCursorPixel = layer.fromPixel;
    }
  }

  static writingMouseDownEvent(event) {
    let activePixel = canvas.getPixelById(event.target.id);
    if (!TextLayer.focusedOtherTextLayer(activePixel)) {
      modeMaster.change("writing", "draw");
      layerManager.unselectAll();
    }
  }

  static keyDownEvent(event) {
    var layer = layerManager.editingTextLayer;
    if (layer && layer.is("text")) layerManager.refresh(() => layer.draw(event.key));
  }

  static focusedOtherTextLayer(activePixel) {
    layerManager.tidyLayers(); // Incase an empty text layer was left behind.
    let layer = layerManager.getLayerByPixelId(activePixel.id());

    // Unselect / remove cursor from any previous editing text layer.
    if (layerManager.editingTextLayer) {
      layerManager.editingTextLayer.clearLastCursor();

      // If the current editing text is selected, it should become unselected given
      // a new text layer has been selected for editing, though in a table this doesn't make
      // visual sense as the whole table is selected as a group.
      if (layerManager.editingTextLayer.isSelected() && !layerManager.editingTextLayer.hasTable()) {
        layerManager.editingTextLayer.unselect();
      }
    }

    // Setup the newly selected layer (might be the same).
    if (layer && layer.is("text")) {
      layer.moveCursorToPixel(activePixel);
      layerManager.editingTextLayer = layer;
      return true;
    }
    return false;
  }

  isHappy() {
    if (this.hasTable()) {
      // If the textLayer has a parent table, it's happiness
      // should also depend on the parent (it should rollback if the parent has
      // become unhappy)
      return layerManager.getLayerById(this.tableId).isHappy() && super.isHappy();
    }
    return super.isHappy();
  }

  clearLastCursor() {
    if (this.lastCursorPixel) this.lastCursorPixel.stopCursor();
  }

  copy(identical=false) {
    let layerCopy = super.copy(identical);
    layerCopy.contents = structuredClone(this.contents);
    if (identical) layerCopy.tableId = this.tableId;
    return layerCopy;
  }


  stash() {
    super.stash();
    this.stashed.cursor   = this.cursor;
    this.stashed.contents = this.contents.map(c => c);
  }

  rollback() {
    super.rollback();
    this.cursor   = this.stashed.cursor;
    this.contents = this.stashed.contents;
  }

  getKeyedJointPixels() {
    if (this.hasTable()) return {}; // The table itself will be joinable instead.
    let [maxCol, minCol, maxRow, minRow] = this.getMinMaxRowsCols();
    let halfwayRow = minRow + roundHalf((maxRow - minRow) / 2);
    let halfwayCol = minCol + roundHalf((maxCol - minCol) / 2);
    return {
      l: canvas.getPixelByRowCol(halfwayRow, minCol - 1), // Left
      r: canvas.getPixelByRowCol(halfwayRow, maxCol + 1), // Right
      t: canvas.getPixelByRowCol(minRow - 1, halfwayCol), // Top
      b: canvas.getPixelByRowCol(maxRow + 1, halfwayCol), // Bottom
    }
  }

  getLength() {
    return this.contents.length;
  }

  moveCursorToPixel(pixel) {
    this.clearLastCursor();
    let pixIndex = this.getPixelIndex(pixel.id());
    // Work out selected line using row diff from start.
    let line = pixel.row - this.fromPixel.row;
    // For each line, add a cursor position to make up for \n's.
    var cursor = pixIndex + line + 1;
    // If the user has selected the end, decrement the cursor once so that it
    // doesn't flip to the beginning.
    this.cursor = this.pixIndex == this.pixels.length - 1? cursor - 1: cursor;
    this.lastCursorPixel = pixel;
    pixel.startCursor();
  }

  getCursorLineOffset() {
    for (var i = this.cursor; i >= 0; i --) {
      if (i == 0) {
        return this.cursor - i;
      } else if (this.contents[i] == "\n") {
        if ((this.cursor - i) == 0) {
          continue;
        }
        return this.cursor - i - 1;
      }
    }
  }

  getCurrentLine() {
    var line = 0;
    for (var i = 0; i < this.getLength(); i++) {
      if (i == this.cursor || i + 1 == this.getLength()) return line;
      if (this.contents[i] == "\n") line ++;
    }
    return 0;
  }

  getLineStart(lineNum) {
    var line = 0;
    for (var i = 0; i < this.getLength(); i++) {
      if (line == lineNum) return i;
      if (this.contents[i] == "\n") line ++;
    }
    return i;
  }

  getLineLengths() {
    var lengths = [0];
    for (var i = 0; i < this.getLength(); i++) {
      if (this.contents[i] == "\n") {
        lengths.push(0);
      } else {
        lengths[lengths.length - 1] ++;
      }
    }
    return lengths;
  }

  getVerticalCursor(direction) {
    let currentLine = this.getCurrentLine();
    let lineLengths = this.getLineLengths();
    let cursorLineOffset = this.getCursorLineOffset();
    var nextLine;
    if (direction == "up") {
        nextLine = (currentLine > 0)? currentLine - 1: currentLine;
    } else {
        nextLine = (lineLengths.length - 1 > currentLine)? currentLine + 1: currentLine;
    }
    let col = (lineLengths[nextLine] > cursorLineOffset)? cursorLineOffset: lineLengths[nextLine];
    return this.getLineStart(nextLine) + col;
  }

  draw(key) {
    let committed = this.commit(() => this.writeChar(key), () => this.drawLayer());
    if (!committed) return;
    this.resizeJoinerLayers(true);
    this.updateParentTable();
  }

  updateParentTable() {
    if (this.hasTable()) this.getTable().drawRefreshSpacing(this.id);
  }

  writeChar(key) {
    let length = this.getLength();
    let currentLine = this.getCurrentLine();
    let lineLengths = this.getLineLengths();
    let cursorLineOffset = this.getCursorLineOffset();
    switch (key) {
      case "ArrowDown":
        this.cursor = this.getVerticalCursor("down");
      break;
      case "ArrowUp":
        this.cursor = this.getVerticalCursor("up");
      break;
      case "ArrowRight":
        this.cursor = (this.cursor >= length)? length: this.cursor + 1;
      break;
      case "ArrowLeft":
        this.cursor = (this.cursor <= 0)? 0: this.cursor - 1;
      break;
      case "Enter":
        if (this.contents.length == 0) return;
        this.contents.splice(this.cursor, 0, "\n");
        this.cursor++;
      break;
      case "Backspace":
      case "Delete":
        this.cursor = (this.cursor <= 0)? 0: this.cursor - 1;
        this.contents.splice(this.cursor, 1);
      break;
      default:
        this.contents.splice(this.cursor, 0, key);
        this.cursor++;
      break;
    }
    this.checkNoWrites();
  }

  drawLayer(_, force=false) {
    // Ensure the cursor is cleared incase pre-render clearing
    // didn't (if the cursor isn't on the layer's pixel).
    this.clearLastCursor();
    this.empty();
    let pixels = [];
    var [line, col] = [0, 0];
    for (var i = 0; i < this.getLength(); i++) {
      if (this.contents[i] == "\n") {
        line ++;
        col = 0;
      }
      let pixel = canvas.getPixelByRowCol(
        this.fromPixel.row + line,
        this.fromPixel.col + col
      );
      // Writing out of bounds. Stop the writing! Let a rollback take care of it.
      if (!pixel) return;

      // Draw the cursor if this isn't a redraw (forced).
      if (this.cursor == i + 1 && !force) {
        this.lastCursorPixel = pixel;
        pixel.startCursor();
      }
      if (!pixel || this.contents[i] == "\n") continue;
      this.add(pixel, this.contents[i]);
      col ++;
    }
  }

  checkNoWrites() {
    // This is a quick way of not loosing a layer just because
    // a user backspaced all characters.
    let starterCharIndex = this.contents.indexOf(this.starterChar);
    if (this.noWrites && starterCharIndex == 0) {
      this.contents.splice(starterCharIndex, 1);
      this.cursor = 1;
      this.noWrites = false;
    }
    this.setStarterChar();
  }

  setStarterChar() {
    if (this.contents.length == 0) {
      this.contents = [this.starterChar];
      this.cursor = 1;
      this.noWrites = true;
    }
  }

  paste(text) {
    this.contents.splice(this.cursor, 0, ...text.split(""));
    this.checkNoWrites();
    this.cursor += text.length - 1;
    this.drawLayer();
  }
}


class BaseLineLayer extends Layer {

  static lineBased = true;
  static line = true;

  constructor(firstPixelId) {
    super(firstPixelId);
    this.hasArrowLeft = false;
    this.hasArrowRight = false;
  }

  static decode(encodedLayer) {
    let layer = Layer.decode(encodedLayer);
    layer.hasArrowLeft  = encodedLayer.al;
    layer.hasArrowRight = encodedLayer.ar;
    return layer;
  }

  encode() {
    let encoded = super.encode();
    encoded.al  = this.hasArrowLeft;
    encoded.ar  = this.hasArrowRight;
    return encoded;
  }


  static drawMouseOver(event) {
    Layer.drawMouseOver(event);
    let activePixel = canvas.getPixelById(event.target.id);

    for (var layer of layerManager.layers) {
      for (var jointPixel of layer.getJointPixels()) {
        if (activePixel.isNear(jointPixel) && layerManager.layerPixelIsVisible(layer, jointPixel)) {
          jointPixel.renderJointNear();
          if (activePixel.is(jointPixel)) canvas.setCursor(modeMaster.has("text")? "text": "crosshair");
        } else {
          jointPixel.renderWasSelected();
        }
      }
    }
  }

  copy(identical=false) {
    let layerCopy = super.copy(identical);
    layerCopy.hasArrowLeft = this.hasArrowLeft;
    layerCopy.hasArrowRight = this.hasArrowRight;
    return layerCopy;
  }

  toggleArrows(direction) {
    if (direction == "left") this.hasArrowLeft = !this.hasArrowLeft;
    if (direction == "right") this.hasArrowRight = !this.hasArrowRight;
    this.redraw();
  }

  getEndPixels() {
    if (this.pixels.length > 0) {
      return [this.getFirstPixel(), this.getLastPixel()];
    }
    return [];
  }

  getResizePixels() {
    return this.getEndPixels();
  }

  getJoinerPixels() {
    return this.getEndPixels();
  }

  getResizeOppositePixel(pixel) {
    let resizePixels = this.getResizePixels();
    if (!resizePixels.length) return;
    if (pixel.is(resizePixels[0])) return resizePixels[1];
    if (pixel.is(resizePixels[1])) return resizePixels[0];
  }
}

class FreeLineLayer extends BaseLineLayer {

  static type = "free-line"

  drawLayer(activePixelId, force=false) {
    this.setToPixel(canvas.getPixelById(activePixelId));
    let fromPixel = this.fromPixel;
    let toPixel = this.toPixel;
    let verticalDiff  = toPixel.row - fromPixel.row;
    let lateralDiff   = toPixel.col - fromPixel.col;

    var totalSteps   = Math.max(Math.abs(verticalDiff), Math.abs(lateralDiff));
    var verticalStep = verticalDiff / totalSteps;
    var lateralStep  = lateralDiff / totalSteps;

    var colDraw = fromPixel.col;
    var rowDraw = fromPixel.row;

    var value = "x";

    if (Math.abs(verticalStep) < 0.3){
      value = this.lateralChar;
    } else if (Math.abs(lateralStep) < 0.5) {
      value = this.verticalChar;
    } else if (toPixel.isLeft(fromPixel) && toPixel.isBelow(fromPixel)) {
      value = this.diagForwardChar;
    } else if (toPixel.isRight(fromPixel) && toPixel.isBelow(fromPixel)) {
      value = this.diagBackChar;
    } else if (toPixel.isLeft(fromPixel) && toPixel.isAbove(fromPixel)) {
      value = this.diagBackChar;
    } else if (toPixel.isRight(fromPixel) && toPixel.isAbove(fromPixel)) {
      value = this.diagForwardChar;
    }

    var startValue = value;
    var endValue = value;
    // We double verticalDiff to give it a bias here,
    // as it looks better given width < height,
    // (~double pixels in same visual distance laterally).
    if (Math.abs(verticalDiff) * 2 > Math.abs(lateralDiff)) {
      if (toPixel.isAbove(fromPixel)) {
        endValue = (this.hasArrowLeft) ? this.arrowUpChar : value;
        startValue = (this.hasArrowRight) ? this.arrowDownChar : value;
      } else {
        endValue = (this.hasArrowLeft) ? this.arrowDownChar : value;
        startValue = (this.hasArrowRight) ? this.arrowUpChar : value;
      }
    } else{
      if (fromPixel.isLeft(toPixel)) {
        endValue = (this.hasArrowRight) ? this.arrowRightChar : value;
        startValue = (this.hasArrowLeft) ? this.arrowLeftChar : value;
      } else {
        endValue = (this.hasArrowLeft) ? this.arrowLeftChar : value;
        startValue = (this.hasArrowRight) ? this.arrowRightChar : value;
     }
    }

    this.empty();
    for (var i = 0; i <= totalSteps; i ++) {
      this.add(
        canvas.getPixelByRowCol(roundHalf(rowDraw), roundHalf(colDraw)),
        (i == 0)? startValue: value
      );
      rowDraw += verticalStep;
      colDraw += lateralStep;
    }
    this.add(this.getLastPixel(), endValue);
  }
}

class StepLineLayer extends BaseLineLayer {

  static type = "step-line";

  getKeyedJointPixels() {
    var lastRow = this.getFirstPixel().row;
    var index = 0;
    for (var pixel of this.pixels) {
      if (pixel.row != lastRow) {
        return {m: this.pixels[index - 1]}; // Middle
      }
      index ++;
    }
    return {m: this.getLastPixel()}; // Middle
  }

  drawLayer(activePixelId, force=false) {
    this.setToPixel(canvas.getPixelById(activePixelId));

    /* Try and draw the step line both ways e.g
        _____
        |                |
        |       Vs.   ___|

    and choose which ever is more visible depending on other layers overlapping.
    */
    let layersToAvoid = [
      SquareLayer.type,
      CircleLayer.type,
      DiamondLayer.type,
      TableLayer.type
    ];
    this.drawFromTo(this.fromPixel, this.toPixel);
    let resultNorm = layerManager.getNearOverlappingCount(this, layersToAvoid);
    this.drawFromTo(this.toPixel, this.fromPixel);
    let resultFlip = layerManager.getNearOverlappingCount(this, layersToAvoid);
    if (resultNorm > resultFlip) {
      this.drawFromTo(this.toPixel, this.fromPixel);
    } else {
      this.drawFromTo(this.fromPixel, this.toPixel);
    }
  }

  drawFromTo(fromPixel, toPixel) {
    this.empty();
    let verticalDiff  = toPixel.row - fromPixel.row;
    let lateralDiff   = toPixel.col - fromPixel.col;
    let absVerticalDiff = Math.abs(verticalDiff);
    let absLateralDiff = Math.abs(lateralDiff);

    let [lateralArrowValue, verticalArrowValue] = this.getArrowChars(fromPixel, toPixel);
    var cornerChar = this.getCornerChar(fromPixel, toPixel);

    var drawCol = fromPixel.col;
    var drawRow = fromPixel.row;

    for (var i = 0; i < absLateralDiff; i ++) {
      this.add(
        canvas.getPixelByRowCol(fromPixel.row, drawCol),
        (i == 0)? lateralArrowValue: this.lateralChar
      );
      drawCol += lateralDiff / absLateralDiff;
    }

    if (verticalDiff && !lateralDiff) {
      cornerChar = this.verticalChar;
    } else if (!verticalDiff && lateralDiff) {
      cornerChar = this.lateralChar;
    }
    this.add(canvas.getPixelByRowCol(drawRow, drawCol), cornerChar);

    for (var i = 1; i <= absVerticalDiff; i ++) {
      drawRow += verticalDiff / absVerticalDiff;
      let value = (verticalDiff && lateralDiff)? cornerChar: this.verticalChar;
      this.add(
        canvas.getPixelByRowCol(drawRow, toPixel.col),
        (i == absVerticalDiff)? verticalArrowValue: this.verticalChar
      );
    }
  }

  getCornerChar(fromPixel, toPixel) {
    if (fromPixel.col < toPixel.col) {
      return fromPixel.row < toPixel.row? this.cornerTopRightChar:  this.cornerBottomRightChar;
    } else {
      return fromPixel.row < toPixel.row? this.cornerTopLeftChar:  this.cornerBottomLeftChar;
    }
    return "";
  }

  getArrowChars(fromPixel, toPixel) {
    var lateralArrowValue = this.lateralChar;
    var verticalArrowValue = this.verticalChar;
    if (fromPixel.col > toPixel.col) {
      // Vertical line is on left
      //    |
      //    |
      //    |____
      if (this.hasArrowRight) lateralArrowValue = this.arrowRightChar;
      if (this.hasArrowLeft) {
        verticalArrowValue = fromPixel.row > toPixel.row? this.arrowUpChar: this.arrowDownChar;
      }
    } else {
      // Vertical line is on left
      //       |
      //       |
      //    ___|
      if (this.hasArrowLeft) lateralArrowValue = this.arrowLeftChar;
      if (this.hasArrowRight) {
       verticalArrowValue = fromPixel.row > toPixel.row? this.arrowUpChar: this.arrowDownChar;
      }
    }
    return [lateralArrowValue, verticalArrowValue];
  }
}


class SwitchLineLayer extends BaseLineLayer {

  static type = "switch-line";

  getKeyedJointPixels() {
    // This finds the two corners of a switch line.
    let firstPixel = this.getFirstPixel();
    if(this.pixels.length < 2) return {0: firstPixel, 1: firstPixel};
    let joints = [];
    for (var index = 1; index < this.pixels.length - 1; index ++) {
      let pixel = this.pixels[index];
      let lastPixel = this.pixels[index - 1];
      let nextPixel = this.pixels[index + 1];
      if (
        (lastPixel.row == pixel.row && pixel.row != nextPixel.row) ||
        (lastPixel.col == pixel.col && pixel.col != nextPixel.col)
      ) {
        joints.push(pixel);
      }
    }

    // This means the line is straight, so we just join to the middle.
    if (joints.length != 2) {
      let middlePixel = this.getMiddlePixel();
      return {0: middlePixel, 1: middlePixel};
    }

    // This ensures the keys are the same for the meaningful locations,
    // regardless of a flip.
    let keyedJoints = {};
    if (joints[0].row > joints[1].row || joints[0].col > joints[1].col) {
      keyedJoints[0] = joints[0];
      keyedJoints[1] = joints[1];
    } else {
      keyedJoints[0] = joints[1];
      keyedJoints[1] = joints[0];
    }
    return keyedJoints;
  }

  drawLayer(activePixelId, force=false) {
    this.setToPixel(canvas.getPixelById(activePixelId));
    let fromPixel = this.fromPixel;
    let toPixel = this.toPixel;
    let verticalDiff  = toPixel.row - fromPixel.row;
    let lateralDiff   = toPixel.col - fromPixel.col;
    let absVerticalDiff = Math.abs(verticalDiff);
    let absLateralDiff = Math.abs(lateralDiff);

    /*
    Try and draw the switch line both ways e.g
        _____
        |                 |
        |             ____|
     ___|       Vs.   |



    and choose which ever is more visible depending on other layers overlapping.
    If there aren't notable overlaps, choose based on which direction is favoured.
    */
    let layersToAvoid = [
      SquareLayer.type,
      CircleLayer.type,
      DiamondLayer.type,
      TableLayer.type
    ];
    this.drawVertical(fromPixel, toPixel);
    let verticalOverlap = layerManager.getNearOverlappingCount(this, layersToAvoid);
    this.drawLateral(fromPixel, toPixel);
    let lateralOverlap = layerManager.getNearOverlappingCount(this, layersToAvoid);
    if (verticalOverlap > lateralOverlap) {
      this.drawLateral(fromPixel, toPixel);
    } else if (lateralOverlap > verticalOverlap) {
      this.drawVertical(fromPixel, toPixel);
    } else if (absVerticalDiff > absLateralDiff) {
      this.drawVertical(fromPixel, toPixel);
    } else {
      this.drawLateral(fromPixel, toPixel);
    }
  }

  drawVertical(fromPixel, toPixel) {
    let [firstChar, lastChar] = this.getArrowCharsVertical(fromPixel, toPixel);
    let [firstCornerChar, lastCornerChar] = this.getCornerCharsVertical(fromPixel, toPixel);
    this.drawFromTo(
      fromPixel.col,
      fromPixel.row,
      toPixel.col,
      toPixel.row,
      [this.verticalChar, this.lateralChar, firstChar, lastChar, firstCornerChar, lastCornerChar],
      (a, b) => canvas.getPixelByRowCol(a, b),
    );
  }

  drawLateral(fromPixel, toPixel) {
    let [firstChar, lastChar] = this.getArrowCharsLateral(fromPixel, toPixel);
    let [firstCornerChar, lastCornerChar] = this.getCornerCharsLateral(fromPixel, toPixel);
    this.drawFromTo(
      fromPixel.row,
      fromPixel.col,
      toPixel.row,
      toPixel.col,
      [this.lateralChar, this.verticalChar, firstChar, lastChar, firstCornerChar, lastCornerChar],
      (a, b) => canvas.getPixelByRowCol(b, a),
    );
  }

  drawFromTo(fromPixelCol, fromPixelRow, toPixelCol, toPixelRow, chars, pixelFunc) {
    this.empty();
    let [mainChar, midChar, firstChar, lastChar, firstCornerChar, lastCornerChar] = chars;
    let diffA = toPixelRow - fromPixelRow;
    let diffB = toPixelCol - fromPixelCol;
    let absDiffA = Math.abs(diffA);
    let absDiffB = Math.abs(diffB);
    var drawCol = fromPixelCol;
    var drawRow = fromPixelRow;
    /*
     The following three loops represent each part of a
     switch layer in order.

     E.g

    "Lateral"
                           __________
                           |     3
                 __________| 2
                     1

    "Vertical"

                      | 1
                      |
                      |____
                        2  |
                           | 3
                           |

    Note, the logic is the same both ways, but to draw laterally,
    this method is called with cols and rows swapped.
    It's quite confusing but I've found it works wonderfully.
    */

    let halfwayA = roundHalf(absDiffA / 2);
    // First line
    for (var i = 0; i < halfwayA; i ++) {
      this.add(pixelFunc(drawRow, drawCol), (i == 0)? firstChar: mainChar);
      drawRow += diffA / absDiffA;
    }

    // If there is no middle line (no diff in a direction),
    // fill with a continuation pixel using mainChar.
    if (absDiffB == 0) {
      this.add(pixelFunc(drawRow, drawCol), mainChar);
    } else {
      // First corner
      this.add(pixelFunc(drawRow, drawCol), firstCornerChar);
      // Second line (middle)
      for (var i = 0; i < absDiffB - 1; i ++) {
        drawCol += diffB / absDiffB;
        this.add(pixelFunc(drawRow, drawCol), midChar);
      }
      drawCol += diffB / absDiffB;
      // Second corner
      this.add(pixelFunc(drawRow, drawCol), lastCornerChar);
    }
    // Third line. We use a while to ensure the line is drawn all the way.
    // Otherwise, using, using another "halfwayA" might be uneven due to rounding.
    while(drawRow != toPixelRow) {
      drawRow += diffA / absDiffA;
      this.add(pixelFunc(drawRow, toPixelCol), mainChar);
    }

    // This will replace the last char with arrows if needed.
    this.add(pixelFunc(drawRow, toPixelCol), lastChar);
  }

  getArrowCharsVertical(fromPixel, toPixel) {
    var firstChar = this.verticalChar;
    var lastChar = this.verticalChar;
    if (fromPixel.row < toPixel.row) {
      // Going down
      if (fromPixel.col < toPixel.col) {
        // Going right
        if (this.hasArrowRight) lastChar = this.arrowDownChar;
        if (this.hasArrowLeft) firstChar = this.arrowUpChar;
      } else {
        // Going left
        if (this.hasArrowLeft) lastChar = this.arrowDownChar;
        if (this.hasArrowRight) firstChar = this.arrowUpChar;
      }
    } else {
      // Going up
      if (fromPixel.col < toPixel.col) {
        // Going right
        if (this.hasArrowRight) lastChar = this.arrowUpChar;
        if (this.hasArrowLeft) firstChar = this.arrowDownChar;
      } else {
        // Going left
        if (this.hasArrowLeft) lastChar = this.arrowUpChar;
        if (this.hasArrowRight) firstChar = this.arrowDownChar;
      }
    }
    return [firstChar, lastChar];
  }

  getArrowCharsLateral(fromPixel, toPixel) {
    var firstChar = this.lateralChar;
    var lastChar = this.lateralChar;
    if (fromPixel.col < toPixel.col) {
      // Going right
      if (this.hasArrowLeft) firstChar = this.arrowLeftChar;
      if (this.hasArrowRight) lastChar = this.arrowRightChar;
    } else {
      // Going left
      if (this.hasArrowLeft) lastChar = this.arrowLeftChar;
      if (this.hasArrowRight) firstChar = this.arrowRightChar;
    }
    return [firstChar, lastChar];
  }

  getCornerCharsVertical(fromPixel, toPixel) {
    var firstChar = "";
    var lastChar = "";
    if (fromPixel.row < toPixel.row) {
      // Going down
      if (fromPixel.col < toPixel.col) {
        // Going right
        firstChar = this.cornerBottomLeftChar;
        lastChar = this.cornerTopRightChar;
      } else {
        // Going left
        firstChar = this.cornerBottomRightChar;
        lastChar = this.cornerTopLeftChar;
      }
    } else {
      // Going up
      if (fromPixel.col < toPixel.col) {
        // Going right
        firstChar = this.cornerTopLeftChar;
        lastChar = this.cornerBottomRightChar;
      } else {
        // Going left
        firstChar = this.cornerTopRightChar;
        lastChar = this.cornerBottomLeftChar;
      }
    }
    return [firstChar, lastChar];
  }

  getCornerCharsLateral(fromPixel, toPixel) {
    var firstChar = "";
    var lastChar = "";
    if (fromPixel.row < toPixel.row) {
      // Going down
      if (fromPixel.col < toPixel.col) {
        // Going right
        firstChar = this.cornerTopRightChar;
        lastChar = this.cornerBottomLeftChar;
      } else {
        // Going left
        firstChar = this.cornerTopLeftChar;
        lastChar = this.cornerBottomRightChar;
      }
    } else {
      // Going up
      if (fromPixel.col < toPixel.col) {
        // Going right
        firstChar = this.cornerBottomRightChar;
        lastChar = this.cornerTopLeftChar;
      } else {
        // Going left
        firstChar = this.cornerBottomLeftChar;
        lastChar = this.cornerTopRightChar;
      }
    }
    return [firstChar, lastChar];
  }

}


class FreeLayer extends Layer {

  static type = "free";
  static freeChar = "█";

  warningUnicodeChars = ["█", "•"];

  static setFreeChar(char) {
    FreeLayer.freeChar = char;
  }

  static startFreeDraw() {
    layerManager.switchModeCallback();
    modeMaster.add(FreeLayer.freeChar);
  }

  static decode(encodedLayer) {
    let layer = Layer.decode(encodedLayer);
    layer.pixels = encodedLayer.pxs.map(pixelId => canvas.getPixelById(pixelId));
    layer.values = encodedLayer.vls;
    return layer;
  }

  encode() {
    let encoded = super.encode();
    encoded.pxs  = this.pixels.map(pixel => pixel.id());
    encoded.vls  = this.values;
    return encoded;
  }

  redraw() {} // FreeLayers are static and should not be redrawable

  characterWarning(value) {
    if (this.warningUnicodeChars.includes(value) && charManager.charsetForm != "unicode") {
      bodyComponent.informerComponent.report("Warning: using unicode character in non-unicode mode");
    }
  }

  drawLayer(activePixelId, force=false) {
    this.setToPixel(canvas.getPixelById(activePixelId));
    var value = "";
    if (FreeLayer.freeChar == "_lines") {
      let verticalDiff = Math.abs(this.toPixel.row - this.fromPixel.row);
      let lateralDiff = Math.abs(this.toPixel.col - this.fromPixel.col);

      if (verticalDiff > lateralDiff) {
        value = this.verticalChar;
      } else if (lateralDiff > verticalDiff) {
        value = this.lateralChar;
      }
    } else {
      value = FreeLayer.freeChar;
    }
    this.characterWarning(value);
    this.add(this.toPixel, value);
    this.setFromPixel(this.toPixel);
  }
}


class SquareBoundLayer extends Layer {
  static lineBased = true;

  getCornerPixels() {
    if (this.pixels.length == 0) {
      return [];
    }
    let [maxCol, minCol, maxRow, minRow] = this.getMinMaxRowsCols();
    return [
      canvas.getPixelByRowCol(minRow, minCol), // Top left
      canvas.getPixelByRowCol(minRow, maxCol), // Top right
      canvas.getPixelByRowCol(maxRow, maxCol), // Bottom right
      canvas.getPixelByRowCol(maxRow, minCol), // Bottom left
    ]
  }

  getResizePixels() {
    return this.getCornerPixels();
  }

  getResizeOppositePixel(targetPixel) {
    let corners = this.getResizePixels();
    let cornerMatchPixel = this.getResizePixelIndex(targetPixel);
    if (cornerMatchPixel == -1) return;
    let firstPixelIndex = cornerMatchPixel + 2;
    if (firstPixelIndex > 3) firstPixelIndex = firstPixelIndex - 4;
    return corners[firstPixelIndex];
  }
}


class CircleLayer extends Layer {

  static type = "circle";
  static lineBased = true;

  getKeyedJointPixels() {
    let firstPixel = this.getFirstPixel();
    if (this.pixels.length < 4) return {t: firstPixel, r: firstPixel, b: firstPixel, l: firstPixel};
    let [leftPixel, rightPixel, topPixel, bottomPixel] = this.getCornerPixels();
    return {
      t: canvas.getPixelByRowCol(topPixel.row - 1, topPixel.col),
      r: canvas.getPixelByRowCol(rightPixel.row, rightPixel.col + 1),
      b: canvas.getPixelByRowCol(bottomPixel.row + 1, topPixel.col),
      l: canvas.getPixelByRowCol(leftPixel.row, leftPixel.col - 1),
    };
  }

  getCornerPixels() {
    var minCol;
    var maxCol;
    var minRow;
    var maxRow;
    for (let pixel of this.pixels) {
      if (!minCol || pixel.col < minCol.col) minCol = pixel;
      if (!maxCol || pixel.col > maxCol.col) maxCol = pixel;
      if (!minRow || pixel.row < minRow.row) minRow = pixel;
      if (!maxRow || pixel.row > maxRow.row) maxRow = pixel;
    }
    return [minCol, maxCol, minRow, maxRow];
  }

  getResizePixels() {
    return this.getCornerPixels();
  }

  getResizeOppositePixel(targetPixel) {
    let [minCol, maxCol, minRow, maxRow] = this.getCornerPixels();
    return canvas.getPixelByRowCol(
      minRow.row + roundHalf((maxRow.row - minRow.row) / 2),
      minCol.col + roundHalf((maxCol.col - minCol.col) / 2),
    )
  }


  drawLayer(activePixelId, force=false) {
    this.empty();
    this.setToPixel(canvas.getPixelById(activePixelId));
    let verticalDiff = Math.abs(this.toPixel.row - this.fromPixel.row);
    let lateralDiff = Math.abs(this.toPixel.col - this.fromPixel.col);
    var diff = verticalDiff > lateralDiff? verticalDiff: roundHalf(lateralDiff / 2);
    var radius = diff;
    var [col, row] = [0, radius];
    var p = 1 - radius;
    while (col <= row) {
      for (var i = 0; i <= 1; i ++) {
        // This so that we will in the lateral gaps given columns are factored by 2.
        this.add(canvas.getPixelByRowCol(this.fromPixel.row + row, this.fromPixel.col + col * 2 - i), this.lateralChar);
        this.add(canvas.getPixelByRowCol(this.fromPixel.row + row, this.fromPixel.col - col * 2 - i), this.lateralChar);
        this.add(canvas.getPixelByRowCol(this.fromPixel.row - row, this.fromPixel.col + col * 2 - i), this.lateralChar);
        this.add(canvas.getPixelByRowCol(this.fromPixel.row - row, this.fromPixel.col - col * 2 - i), this.lateralChar);
      }
      this.add(canvas.getPixelByRowCol(this.fromPixel.row + col, this.fromPixel.col + row * 2), this.verticalChar);
      this.add(canvas.getPixelByRowCol(this.fromPixel.row + col, this.fromPixel.col - row * 2), this.verticalChar);
      this.add(canvas.getPixelByRowCol(this.fromPixel.row - col, this.fromPixel.col + row * 2), this.verticalChar);
      this.add(canvas.getPixelByRowCol(this.fromPixel.row - col, this.fromPixel.col - row * 2), this.verticalChar);
      // A clever algorithm I found online that I don't really understand...
      // https://en.wikipedia.org/wiki/Midpoint_circle_algorithm
      col += 1;
      if (p < 0) {
        p += 2 * col + 1;
      } else {
        row -= 1;
        p += 2 * (col - row) + 1;
      }
    }
  }
}


class DiamondLayer extends Layer {

  static type = "diamond";
  static lineBased = true;

  getKeyedJointPixels() {
    let firstPixel = this.getFirstPixel();
    if (this.pixels.length < 4) return {t: firstPixel, r: firstPixel, b: firstPixel, l: firstPixel};
    let [leftPixel, rightPixel, topPixel, bottomPixel] = this.getCornerPixels();
    return {
      t: topPixel,
      r: rightPixel,
      b: bottomPixel,
      l: leftPixel,
    };
  }

  getCornerPixels() {
    var minCol;
    var maxCol;
    var minRow;
    var maxRow;
    for (let pixel of this.pixels) {
      if (!minCol || pixel.col < minCol.col) minCol = pixel;
      if (!maxCol || pixel.col > maxCol.col) maxCol = pixel;
      if (!minRow || pixel.row < minRow.row) minRow = pixel;
      if (!maxRow || pixel.row > maxRow.row) maxRow = pixel;
    }
    return [minCol, maxCol, minRow, maxRow];
  }

  getResizePixels() {
    return this.getCornerPixels();
  }

  getResizeOppositePixel(targetPixel) {
    let [minCol, maxCol, minRow, maxRow] = this.getCornerPixels();
    return canvas.getPixelByRowCol(
      minRow.row + roundHalf((maxRow.row - minRow.row) / 2),
      minCol.col + roundHalf((maxCol.col - minCol.col) / 2),
    )
  }

  drawLayer(activePixelId, force=false) {
    this.setToPixel(canvas.getPixelById(activePixelId));
    let verticalDiff = Math.abs(this.toPixel.row - this.fromPixel.row);
    let lateralDiff = Math.abs(this.toPixel.col - this.fromPixel.col);
    var diff = verticalDiff > lateralDiff? verticalDiff: roundHalf(lateralDiff / 2);

    var middlePixel = this.fromPixel;

    let topPixel = canvas.getPixelByRowCol(middlePixel.row - diff, middlePixel.col);
    let leftPixel = canvas.getPixelByRowCol(middlePixel.row, middlePixel.col - (diff * 2));
    let rightPixel = canvas.getPixelByRowCol(middlePixel.row, middlePixel.col + (diff * 2));
    let bottomPixel = canvas.getPixelByRowCol(middlePixel.row + diff, middlePixel.col);

    let corners = [topPixel, leftPixel, rightPixel, bottomPixel];
    if (!corners.every(Boolean)) return;

    this.empty();
    this.add(corners[0], this.cornerDiamondLateralChar);
    this.add(corners[1], this.cornerDiamondVerticalChar);
    this.add(corners[2], this.cornerDiamondVerticalChar);
    this.add(corners[3], this.cornerDiamondLateralChar);
    for (var backCount = 1; backCount < diff; backCount ++) {
      this.add(
        canvas.getPixelByRowCol(rightPixel.row - backCount, rightPixel.col - (backCount * 2)),
        this.diagBackChar,
      );
      this.add(
        canvas.getPixelByRowCol(bottomPixel.row - backCount, bottomPixel.col - (backCount * 2)),
        this.diagBackChar,
      );
    }
    for (var fCount = 1; fCount < diff; fCount ++) {
      this.add(
        canvas.getPixelByRowCol(leftPixel.row - fCount, leftPixel.col + (fCount * 2)),
        this.diagForwardChar,
      );
      this.add(
        canvas.getPixelByRowCol(bottomPixel.row - fCount, bottomPixel.col + (fCount * 2)),
        this.diagForwardChar,
      );
    }
  }
}

class SquareLayer extends SquareBoundLayer {

  static type = "square";

  getKeyedJointPixels() {
    let fp = this.getFirstPixel();
    if (this.pixels.length < 2) {
      return {tl: fp, tr: fp, br: fp, bl: fp, l: fp, r: fp, b: fp, t: fp};
    }
    let corners = this.getCornerPixels();
    let minRow = corners[0].row;
    let maxRow = corners[2].row;
    let minCol = corners[0].col;
    let maxCol = corners[2].col;
    let halfwayRow = parseInt((maxRow - minRow) / 2);
    let halfwayCol = parseInt((maxCol - minCol) / 2);
    return {
      tl: corners[0], // Top left
      tr: corners[1], // Top right
      br: corners[2], // Bottom right
      bl: corners[3], // Bottom left
      l: canvas.getPixelByRowCol(minRow + halfwayRow, minCol - 1), // Left
      r: canvas.getPixelByRowCol(minRow + halfwayRow, maxCol + 1), // Right
      b: canvas.getPixelByRowCol(maxRow + 1, minCol + halfwayCol), // Bottom
      t: canvas.getPixelByRowCol(minRow - 1, minCol + halfwayCol), // Top
    };
  }

  drawLayer(activePixelId, force=false) {
    this.setToPixel(canvas.getPixelById(activePixelId));
    let topLeftPixel = canvas.getPixelByRowCol(
      Math.min(this.toPixel.row, this.fromPixel.row),
      Math.min(this.toPixel.col, this.fromPixel.col),
    )
    let bottomRightPixel = canvas.getPixelByRowCol(
      Math.max(this.toPixel.row, this.fromPixel.row),
      Math.max(this.toPixel.col, this.fromPixel.col),
    )

    let verticalDiff = bottomRightPixel.row - topLeftPixel.row;
    let lateralDiff = bottomRightPixel.col - topLeftPixel.col;

    if (!verticalDiff || !lateralDiff) return;

    let absVerticalDiff = Math.abs(verticalDiff);
    let absLateralDiff = Math.abs(lateralDiff);
    var rowPos = topLeftPixel.row;
    var colPos = topLeftPixel.col;

    this.empty();

    // Draw corners
    this.add(canvas.getPixelByRowCol(rowPos, colPos), this.cornerTopLeftChar);
    this.add(canvas.getPixelByRowCol(rowPos, bottomRightPixel.col), this.cornerTopRightChar);
    this.add(canvas.getPixelByRowCol(bottomRightPixel.row, colPos), this.cornerBottomLeftChar);
    this.add(canvas.getPixelByRowCol(bottomRightPixel.row, bottomRightPixel.col), this.cornerBottomRightChar);

    // Draw lines
    for(var row = 0; row < absVerticalDiff - 1; row ++) {
      rowPos += verticalDiff / absVerticalDiff;
      this.add(canvas.getPixelByRowCol(rowPos, topLeftPixel.col), this.verticalChar);
      this.add(canvas.getPixelByRowCol(rowPos, bottomRightPixel.col), this.verticalChar);
    }
    for(var col = 0; col < absLateralDiff - 1; col ++) {
      colPos += lateralDiff / absLateralDiff;
      this.add(canvas.getPixelByRowCol(topLeftPixel.row, colPos), this.lateralChar);
      this.add(canvas.getPixelByRowCol(bottomRightPixel.row, colPos), this.lateralChar);
    }
  }
}


class TableLayer extends SquareBoundLayer {
  static type = "table";

  constructor(firstPixelId) {
    super(firstPixelId);
    this.tblSizeLimit = 20;
    this.defaultCellContents = "text...";
    this.tblColDefaultWidth = this.defaultCellContents.length + 1; // 1 is added to account for the col line
    this.cellTextArchive = {};
    this.textLayers = {};
    this.tblRows = 0;
    this.tblCols = 0;
    this.tblColWidths = {};
    this.tblRowHeights = {};
    this.tblRowDefaultHeight = 2;
  }

  // The next few methods all persist layer data for different reasons,
  // (Copying, commit stashing, and export encoding). Perhaps it could be
  // combined into a 'persist' object, but explicitness is good, right?
  // As this stuff grows, separation should be a blessing.

  static decode(encodedLayer) {
    let layer = Layer.decode(encodedLayer);
    layer.tblCols       = encodedLayer.tblc;
    layer.tblRows       = encodedLayer.tblr;
    layer.tblColWidths  = encodedLayer.tblws;
    layer.tblRowHeights = encodedLayer.tblhs;
    layer.textLayers    = encodedLayer.tbltx;
    return layer;
  }

  encode() {
    let encoded = super.encode();
    // This layer is more complex. we need to encode more stuff.
    encoded.tblc  = this.tblCols;
    encoded.tblr  = this.tblRows;
    encoded.tblws = this.tblColWidths;
    encoded.tblhs = this.tblRowHeights;
    encoded.tbltx = this.textLayers;
    return encoded;
  }

  stash() {
    super.stash();
    // This layer is more complex. we need to stash more stuff.
    this.stashed.textLayers    = structuredClone(this.textLayers); // We watch out for mutation here.
    this.stashed.tblColWidths  = structuredClone(this.tblColWidths);
    this.stashed.tblRowHeights = structuredClone(this.tblRowHeights);
    this.stashed.tblRows       = this.tblRows;
    this.stashed.tblCols       = this.tblCols;
  }

  rollback() {
    super.rollback();
    this.textLayers     = this.stashed.textLayers;
    this.tblColWidths   = this.stashed.tblColWidths;
    this.tblRowHeights  = this.stashed.tblRowHeights;
    this.tblRows        = this.stashed.tblRows;
    this.tblCols        = this.stashed.tblCols;
  }

  copy(identical=false) {
    // We also copy textLayers if it's a full identical copy.
    let layerCopy = super.copy(identical);
    if (identical) layerCopy.textLayers = structuredClone(this.textLayers);

    // Copy row and col counts so that refresh() works immediately for copied tables.
    layerCopy.tblRows       = this.tblRows;
    layerCopy.tblCols       = this.tblCols;
    layerCopy.tblRowHeights = structuredClone(this.tblRowHeights);
    layerCopy.tblColWidths  = structuredClone(this.tblColWidths);
    return layerCopy;
  }

  getKeyedJointPixels() {
    let pixels = {};
    var corners = this.getCornerPixels();
    if (!corners.length) return {};
    let [topLeftPixel, topRightPixel, bottomRightPixel, bottomLeftPixel] = corners;
    var rowPos = topLeftPixel.row + 1;
    var index = 0;
    for (let row = 0; row < this.tblRows; row ++) {
      let height = this.getRowHeight(row);
      rowPos += height;
      let jointPos = rowPos - roundHalf(height / 2) - 1;
      pixels[`l-${index}`] = canvas.getPixelByRowCol(jointPos, topLeftPixel.col - 1); // Left
      pixels[`r-${index}`] = canvas.getPixelByRowCol(jointPos, topRightPixel.col + 1); // Right
      index ++;
    }
    var colPos = topLeftPixel.col + 1;
    var index = 0;
    for (let col = 0; col < this.tblCols; col ++) {
      let width = this.getColWidth(col);
      colPos += width;
      let jointPos = colPos - roundHalf(width / 2);
      pixels[`t-${index}`] = canvas.getPixelByRowCol(topLeftPixel.row - 1, jointPos); // Top
      pixels[`b-${index}`] = canvas.getPixelByRowCol(bottomLeftPixel.row + 1, jointPos); // Bottom
      index ++;
    }
    return pixels;
  }

  getNewTblRows(verticalDiff) {
    // Showing/hiding a row depends on it's height, the direction of the mouse,
    // and the mouse travelling enough to justify show/hiding based on the row's height.
    // E.g, to hide a row, the mouse moves back by half it's height (or forward to show).
    let relVerticalDiff = verticalDiff - this.getTablePixelHeight();
    let belowRowHeight = this.getRowHeight(this.tblRows);
    let aboveRowHeight = this.getRowHeight(this.tblRows - 1);
    let nextRowHeight = relVerticalDiff > 0? belowRowHeight: aboveRowHeight;
    return Math.abs(this.tblRows + roundHalf(relVerticalDiff / nextRowHeight));
  }

  getNewTblCols(lateralDiff) {
    // Showing/hiding a column depends on it's height, the direction of the mouse,
    // and the mouse travelling enough to justify show/hiding based on the col's width.
    // E.g, to hide a column, the mouse moves back by half it's width (or forward to show).
    let relLateralDiff = lateralDiff - this.getTablePixelWidth();
    let belowColWidth = this.getColWidth(this.tblCols);
    let aboveColWidth = this.getColWidth(this.tblCols - 1);
    let nextColWidth = relLateralDiff > 0? belowColWidth: aboveColWidth;
    return Math.abs(this.tblCols + roundHalf(relLateralDiff / nextColWidth));
  }

  drawLayer(activePixelId, force=false) {
    this.setToPixel(canvas.getPixelById(activePixelId));
    let topLeftPixel = this.getTopLeftPixel();
    let bottomRightPixel = this.getBottomRightPixel();
    let newTblRows = this.getNewTblRows(bottomRightPixel.row - topLeftPixel.row);
    let newTblCols = this.getNewTblCols(bottomRightPixel.col - topLeftPixel.col);

    if (!force) {
      // Don't bother updating the table if no proper changes have been calculated.
      if (newTblRows == this.tblRows && newTblCols == this.tblCols) return;
      if (newTblCols == 0 || newTblRows == 0) return;
      // ...or if the size limit is hit...
      if (newTblRows >= this.tblSizeLimit || newTblCols >= this.tblSizeLimit) {
        bodyComponent.informerComponent.report("Table getting too big", "bad");
        return;
      };
    }

    // This sequence does one draw of the whole table.
    // We start by setting new row/col properties,
    // which represent how many rows/cols are visible.
    this.tblRows = newTblRows;
    this.tblCols = newTblCols;

    // We ungroup the existing layers as a new group will be
    // needed since layers might get removed/added.
    this.ungroup();

    // The table layer itself get's drawn.
    this.drawFrame(topLeftPixel);

    // All layers that should no longer be visible are removed,
    // though their contents preserved.
    this.emptyTextLayers();

    // New rows/cols get their new layers added.
    this.addTextLayers(topLeftPixel);

    // Depending on the new location of rows/cols, we must
    // shuffle around layers so they stick to the correct cell.
    this.moveTextLayers(topLeftPixel);

    // Finally, group the updated set of layers.
    this.group();
  }

  drawFrame(topLeftPixel) {
    this.empty();
    let tblHeight = this.getTablePixelHeight();
    let tblWidth = this.getTablePixelWidth();
    let fromRow = topLeftPixel.row;
    let fromCol = topLeftPixel.col;
    let toRow = fromRow + tblHeight;
    let toCol = fromCol + tblWidth;
    // Draw corners...
    this.add(canvas.getPixelByRowCol(fromRow, fromCol), this.cornerTopLeftChar);
    this.add(canvas.getPixelByRowCol(fromRow, toCol), this.cornerTopRightChar);
    this.add(canvas.getPixelByRowCol(toRow, fromCol), this.cornerBottomLeftChar);
    this.add(canvas.getPixelByRowCol(toRow, toCol), this.cornerBottomRightChar);

    // Draw row lines with spacing based on text..
    // -----------------
    //
    // -----------------
    // -----------------
    var row = fromRow;
    for (var tblRow = 0; tblRow <= this.tblRows; tblRow ++) {
      for (var col = fromCol + 1; col < toCol; col++) {
        this.add(canvas.getPixelByRowCol(row,  col), this.lateralChar);
      }
      row += this.getRowHeight(tblRow);
    }
    // Draw col lines with spacing based on text..
    // |      |   |    |
    // |      |   |    |
    // |      |   |    |
    var col = fromCol;
    for (var tblCol = 0; tblCol <= this.tblCols; tblCol ++) {
      for (var row = fromRow + 1; row < toRow; row ++) {
        this.add(canvas.getPixelByRowCol(row,  col), this.verticalChar);
      }
      col += this.getColWidth(tblCol);
    }
  }

  refreshSpacing(textLayerId) {
    let topLeftPixel = this.getTopLeftPixel();
    this.setNewTextSpacing(textLayerId);
    this.drawFrame(topLeftPixel);
    this.moveTextLayers(topLeftPixel);

    // Here, we update the from/to pixels so that redraws
    // draw from the correct places (given the table size has changed).
    let corners = this.getCornerPixels();
    this.setFromPixel(corners[0]);
    this.setToPixel(corners[2]);

    // The textLayer that has changed needs another chance to rollback
    // in case it's parent table has since become unhappy. Hence,
    // we carry out an empty commit.
    let textLayer = layerManager.getLayerById(textLayerId);
    textLayer.commit(() => {});
  }

  drawRefreshSpacing(textLayerId) {
    let committed = this.commit(() => this.refreshSpacing(textLayerId));
    if (committed) this.resizeJoinerLayers(true);
  }

  makeCellId(row, col) {
    return `${row},${col}`;
  }

  parseCellId(cellId) {
    return cellId.split(",")
  }

  ungroup() {
    // Ungroup all layers.
    let layers = this.getTextLayers().concat(this);
    if (!layers.every(Boolean)) return;
    layerManager.groupManager.ungroupLayers(layers);
  }

  group() {
    // Group all existing visible layers, and ensure the table is always selected together.
    let textLayers = this.getTextLayers();
    if (this.isSelected()) textLayers.forEach(layer => layer.select());
    layerManager.groupManager.groupLayers(textLayers.concat(this));
  }

  getBottomRightPixel() {
    return canvas.getPixelByRowCol(
      Math.max(this.toPixel.row, this.fromPixel.row),
      Math.max(this.toPixel.col, this.fromPixel.col),
    );
  }

  getTopLeftPixel() {
    return canvas.getPixelByRowCol(
      Math.min(this.toPixel.row, this.fromPixel.row),
      Math.min(this.toPixel.col, this.fromPixel.col),
    );
  }

  getTextLayers() {
    return Object.values(this.textLayers).map(layerId => layerManager.getLayerById(layerId));
  }


  getCellFromTextLayerId(textLayerId) {
    for (let cellId in this.textLayers) {
      if (this.textLayers[cellId] == textLayerId) return this.parseCellId(cellId);
    }
  }

  getTablePixelHeight() {
    var height = 0;
    for (let row = 0; row < this.tblRows; row ++) height += this.getRowHeight(row);
    return height;
  }

  getTablePixelWidth() {
    var width = 0;
    for (let col = 0; col < this.tblCols; col ++) width += this.getColWidth(col);
    return width;
  }

  getRowHeight(row) {
    return this.tblRowHeights[row] || this.tblRowDefaultHeight;
  }

  getColWidth(col) {
    return this.tblColWidths[col] || this.tblColDefaultWidth;
  }

  setRowHeight(row, height) {
    this.tblRowHeights[row] = height;
  }

  setColWidth(col, width) {
    this.tblColWidths[col] = width;
  }


  emptyTextLayers() {
    for (let cellId in this.textLayers) {
      if(!this.cellIsVisible(cellId)) this.archiveCell(cellId);
    }
  }

  cellIsVisible(cellId) {
    let [row, col] = this.parseCellId(cellId);
    return (row < this.tblRows && col < this.tblCols);
  }

  archiveCell(cellId) {
    let textLayer = this.getTextLayer(cellId);
    this.cellTextArchive[cellId] = textLayer.contents;
    textLayer.commit(() => textLayer.empty());
    delete this.textLayers[cellId];
  }

  reviveCell(cellId, absRow, absCol) {
    let textLayer = new TextLayer(
        canvas.getPixelByRowCol(absRow, absCol).id(), this.id
    );
    textLayer.contents = this.cellTextArchive[cellId] || this.defaultCellContents.split("");
    layerManager.addSecond(textLayer);
    this.textLayers[cellId] = textLayer.id;
    textLayer.commit(() => textLayer.drawLayer());
  }

  getTextLayer(cellId) {
    return layerManager.getLayerById(this.textLayers[cellId]);
  }

  setNewTextSpacing(textLayerId) {
    let [cellRow, cellCol] = this.getCellFromTextLayerId(textLayerId);
    // For the row and column that has a change, reset the height/widths for a fresh count.
    this.setRowHeight(cellRow, 0);
    this.setColWidth(cellCol, 0);
    for (let cellId in this.textLayers) {
      let [row, col] = this.parseCellId(cellId);
      // If the edited text is not on the same row or column as this text,
      // we don't need to consider it.
      if (row != cellRow && col != cellCol) continue;
      let lineLengths = this.getTextLayer(cellId).getLineLengths();
      let [textHeight, textWidth] = [lineLengths.length + 1, Math.max(...lineLengths) + 1];
      // If the row is on the edited text's row, consider it's height as the new tallest.
      if (row == cellRow && textHeight > this.tblRowHeights[row]) this.setRowHeight(row, textHeight)
      // If the col is on the edited text's col, consider it's width as the new longest.
      if (col == cellCol && textWidth > this.tblColWidths[col]) this.setColWidth(col, textWidth);
    }
  }

  addTextLayers(topLeftPixel) {
    var absRow = topLeftPixel.row;
    var absCol = topLeftPixel.col;
    for(var tblRow = 0; tblRow < this.tblRows; tblRow ++) {
      for (var tblCol = 0; tblCol < this.tblCols; tblCol ++) {
        let cellId = this.makeCellId(tblRow, tblCol);
        var textLayer = this.getTextLayer(cellId);
        // If a table rollback caused a TextLayer to empty (but it becomes visible again),
        // we must ensure it is redrawn here.
        if (textLayer && !textLayer.pixels.length) {
          textLayer.commit(() => textLayer.drawLayer());
        }
        // If the layer doesn't exist, add a new layer and fill it with any
        // saved content from the past at the same cell location.
        if (!textLayer) this.reviveCell(cellId, 1 + absRow, 1 + absCol);
        absCol += this.getColWidth(tblCol);
      }
      absCol = topLeftPixel.col;
      absRow += this.getRowHeight(tblRow);
    }
  }

  moveTextLayers(topLeftPixel) {
    var absRow = topLeftPixel.row;
    var absCol = topLeftPixel.col;
    for(var tblRow = 0; tblRow < this.tblRows; tblRow ++) {
      for (var tblCol = 0; tblCol < this.tblCols; tblCol ++) {
        let textLayer = this.getTextLayer(this.makeCellId(tblRow, tblCol));
        // Add 1s here to locate the text within the cell.
        let verticalDiff = 1 + absRow - textLayer.fromPixel.row;
        let lateralDiff = 1 + absCol - textLayer.fromPixel.col;
        // If the cell has changed position, then move the layer.
        if (verticalDiff || lateralDiff) {
          textLayer.commit(() => textLayer.move(verticalDiff, lateralDiff));
        }
        absCol += this.getColWidth(tblCol);
      }
      absCol = topLeftPixel.col;
      absRow += this.getRowHeight(tblRow);
    }
  }
}


/////////////////////
//// COMPONENTS /////
/////////////////////

class Component {
  _MagicMethodEventPrefix = "on";
  _MagicPropCssPrefix = "css";
  _MagicPropCustomPrefix = "prop";

  value = "";
  children = [];
  type = "div";

  // Use this if you don't want a component's children to be traversed for theme setting.
  skipChildrenTheme = false; 

  constructor(props) {
    this.visible = true;
    if (props) for (let prop in props) this[prop] = props[prop];
  }

  create() {
    this.element = document.createElement(this.type);
  }

  registerMagicProps() {
    var obj = this;
    // Get all properties
    let props = Object.keys(obj);

    // Get all methods
    let allMethods = new Set();
    while (obj = Reflect.getPrototypeOf(obj)) {
      let keys = Reflect.ownKeys(obj);
      keys.forEach((key) => allMethods.add(key));
    }
    props = props.concat(Array.from(allMethods.values()));

    // Assign magic functionality to each magic property type
    let mainProps = props.filter(prop => prop.includes("_"))

    // TODO: Consider if this priority logic is worth while.
    // If there is an intermediate class, Javascript constructors initialize
    // class properties of that class after the base constructor is called :/
    // This overrides properties being reasonably sent from a child class. 
    // Here, we hack together a 'feature' where we can capitalize the derived property's
    // first letter so it takes priority.
    let highPriorProps = mainProps.filter(prop => /^[A-Z]*$/.test(prop.substring(0, 1)));
    let lowPriorProps = mainProps.filter(prop => /^[a-z]*$/.test(prop.substring(0, 1)));

    for (let prop of lowPriorProps.concat(highPriorProps)) {
      let [type, name] = prop.split("_");
      switch(type.toLowerCase()) {
        case this._MagicPropCustomPrefix:
          this.element.setAttribute(name, this[prop]);
        case this._MagicPropCssPrefix:
          this.css(name, this[prop]);
        case this._MagicMethodEventPrefix:
          this.element.addEventListener(name.toLowerCase(), () => this[prop]());
        break;
      }
    }
  }

  renderChildren() {
    this.children = this.defineChildren();
    for (let child of this.children) {
      child.render(this);
    }
  }

  defineChildren() { return this.children; }

  defineTheme() {}

  renderTheme() {
    if (this.skipTheme) return;
    this.defineTheme();
    if (this.skipChildrenTheme) return;
    this.children.forEach(child => child.renderTheme());
  }

  renderCallback() {};

  id() {return ""};


  assignParent(parent) {
    this.parent = parent;
    this.parent[this.accessibleBy] = this;
    this.parent.element.appendChild(this.element);
  }

  render(parent) {
    this.create();
    this.setId();
    this.setValue(this.value); // TODO: this.value should be called initialValue or use prop_value
    this.registerMagicProps();
    this.renderChildren();
    this.assignParent(parent);
    this.renderTheme();
    this.renderCallback();
  }

  addChild(child) {
    this.children.push(child);
    child.render(this);
  }

  css(style, value) {
    // Check for priority styles
    if (this["Css_" + style] != undefined) value = this["Css_" + style];

    let valueFromTheme = themeManager.getTheme()[value];
    this.element.style[style] = valueFromTheme? valueFromTheme: value;
  }

  setId() {
    let id = this.id();
    if (id) this.element.id = id;
  }

  setValue(value) {
    this.value = value;
    this.element.value = value;
    this.element.innerHTML = value;
  }

  getValue() {
    return this.element.value;
  }

  show() {
    this.visible = true;
    this.css("display", "block");
  }

  hide() {
    this.visible = false;
    this.css("display", "none");
  }

  toggle() {
    this.visible? this.hide(): this.show();
  }
}


class Pixel extends Component {

  type = "pixel";

  css_position = "absolute";

  constructor(row, col) {
    super();
    this.row = row;
    this.col = col;
    this.defaultBorder = "none";
    this.cursorFlashInterval = null;
    this.selected = false;
  }

  id() {
    return Pixel.makeId(this.row, this.col);
  }

  is(pixel) {
    return this.id() == pixel.id();
  }

  static makeId(row, col) {
    return `px@${row}/${col}`
  }

  renderSelected() {
    this.selected = true;
    this.css("backgroundColor", "pixelSelectedBgColor");
    this.css("color", "pixelSelectedFgColor");
  }

  renderUnselected() {
    this.selected = false;
    this.css("backgroundColor", "pixelNormalBgColor");
    this.css("color", "pixelNormalFgColor");
  }

  renderResizable() {
    this.css("backgroundColor", "pixelResizeBgColor");
    this.css("borderRadius", "10px");
  }

  renderAreaSelected() {
    this.css("backgroundColor", "areaSelectionBgColor");
  }

  renderJoint() {
    this.css("backgroundColor", "pixelJointBgColor");
    this.css("borderRadius", "10px");
  }

  renderJointNear() {
    this.css("backgroundColor", "pixelJointNearBgColor");
    this.css("borderRadius", "10px");
  }

  renderWasSelected() {
    this.selected? this.renderSelected(): this.renderUnselected();
  }

  stopCursor() {
    this.renderNoCursor();
    if (this.cursorFlashInterval) clearInterval(this.cursorFlashInterval);
  }

  renderNoCursor() {
    this.css("border", this.defaultBorder);
  }

  renderCursor() {
    this.css("borderRight", `1px solid ${themeManager.getTheme().pixelCursorColor}`);
  }

  startCursor() {
    this.renderCursor();
    setTimeout(() => this.renderNoCursor(), 500);
    this.cursorFlashInterval = setInterval((pixel) => {
       pixel.renderCursor(); setTimeout(() => pixel.renderNoCursor(), 500);
    }, 1000, this);
  }

  defineTheme() {
    this.renderNormal();
  }

  renderNormal() {
    this.stopCursor();
    this.css("color", "pixelNormalFgColor");
    this.css("backgroundColor", "pixelNormalBgColor");
    this.css("borderRadius", "0px");
  }


  clear() {
    this.setValue("");
    this.renderNormal();
  }

  isAbove(pixel) {
    return this.row < pixel.row;
  }

  isBelow(pixel) {
    return this.row > pixel.row;
  }

  isLeft(pixel) {
    return this.col < pixel.col;
  }

  isRight(pixel) {
    return this.col > pixel.col;
  }

  isNear(pixel, distance=6) {
    return (
      Math.abs(pixel.row - this.row) <= distance &&
      Math.abs(pixel.col - this.col) <= distance
    )
  }

  isNearestTo(pixels) {
    var closestPixel;
    var minDistance = -1;
    for (var pixel of pixels) {
      let distance = Math.abs(pixel.row - this.row) + Math.abs(pixel.col - this.col);
      if (distance < minDistance || minDistance == -1) {
        closestPixel = pixel;
        minDistance = distance;
      }
    }
    return closestPixel;
  }

  scale(size, widthDivider) {
    this.css("marginLeft", `${this.col * size * widthDivider}px`);
    this.css("marginTop", `${this.row * size}px`);
    this.css("height", `${size}px`);
    this.css("width", `${size * widthDivider}px`);
  }

  renderCallback() {
    this.renderNormal();
    this.scale();
  }
}

class CanvasComponent extends Component {
  // Skip the theme to avoid all pixels being traversed. 
  skipChildrenTheme = true;
  skipTheme = false;

  accessibleBy = "canvasComponent";

  rowCount = 65;
  colCount = 225;

  css_userSelect = "none";
  css_position   = "absolute";
  css_zIindex    = "0";
  pixelWidthDivider = 0.5;

  constructor() {
    super();
    this.pixels = {};
  }

  calcPixelSize() {
    return roundDown(window.innerWidth / this.colCount / this.pixelWidthDivider);
  }

  getPixelById(id) {
    return this.pixels[id];
  }

  getPixelByRowCol(row, col) {
    return this.getPixelById(Pixel.makeId(row, col));
  }

  clearPixels(pixels) {
    pixels.forEach((pixel) => pixel.clear());
  }

  clear() {
    for(var pixel in this.pixels) this.pixels[pixel].clear();
  }

  setModeCursor() {
    if (modeMaster.hasOr("moving", "resizing")) {
      this.setCursor("move");
    } else if (modeMaster.hasOr("writing", "text")) {
      this.setCursor("text");
    } else if (modeMaster.hasOr("draw", "drawing")) {
      this.setCursor("crosshair");
    } else {
      this.setCursor("default");
    }
  }

  setCursor(cursor) {
    this.css("cursor", cursor);
  }

  getCroppedRowsCols() {
    var maxCol = -1;
    var minCol = this.colCount;
    var maxRow = -1;
    var minRow = this.rowCount;
    for (let pixelId in this.pixels) {
      let pixel = this.pixels[pixelId];
      if (pixel.getValue() != "") {
        if (pixel.col > maxCol) maxCol = pixel.col;
        if (pixel.col < minCol) minCol = pixel.col;
        if (pixel.row > maxRow) maxRow = pixel.row;
        if (pixel.row < minRow) minRow = pixel.row;
      }
    }
    return [maxCol, minCol, maxRow, minRow];
  }

  async exportToClipboard() {
    layerManager.switchModeCallback();
    // Scrape text from canvas with linebreaks
    var text = "";
    let [maxCol, minCol, maxRow, minRow] = this.getCroppedRowsCols();
    for (var row = minRow; row < maxRow + 1; row++) {
      var rowText = "";
      for (var col = minCol; col < maxCol + 1; col++) {
        let pixel = this.getPixelByRowCol(row, col);
        let pixelValue = pixel.getValue();
        let value = pixelValue == ""? " ": pixelValue;
        rowText += value;
      }
      if(rowText.split("").filter(v => v != " ").length == 0) continue;
      text += `${rowText}\n`;
    }

    let shortKey = await externalHookManager.getShortKeyUrl();
    if (shortKey.length > 0)  {
        text += `\n\nEdit/view: ${shortKey}\n`;
    }

    // This is a slight hack to preserve styles if possible.
    // It fills scraped export text into a dump div styled nicely,
    // then copies it literally from there.
    // This allows same-browser exports to preserve styling.
    bodyComponent.canvasDumpComponent.setValue(text);
    var selection = window.getSelection()
    var range = document.createRange()
    range.selectNodeContents(bodyComponent.canvasDumpComponent.element)
    selection.removeAllRanges()
    selection.addRange(range)
    document.execCommand('copy')
    window.getSelection().removeAllRanges()
    bodyComponent.informerComponent.report("Successfully copied work to clipboard!", "good");
  }

  defineTheme() {
    this.css("backgroundColor", "canvasBgColor");
    this.css("fontFamily", "canvasFont");
  }

  on_mouseDown() {
    bodyComponent.hidePopups();
  }

  defineChildren() {
    for (var row = 0; row < this.rowCount; row++) {
      for (var col = 0; col < this.colCount; col++) {
        let pixel = new Pixel(row, col);
        this.pixels[pixel.id()] = pixel;
      }
    }
    return Object.values(this.pixels);
  }

  scale() {
    let pixelSize = this.calcPixelSize();
    this.css("width", `${this.colCount * pixelSize * this.pixelWidthDivider}px`);
    this.css("height", `${this.rowCount * pixelSize}px`);
    this.css("fontSize", `${pixelSize}px`);
    Object.values(this.pixels).forEach(pixel => pixel.scale(pixelSize, this.pixelWidthDivider));
  }

  renderCallback() {
    this.scale();
    modeMaster.registerCallback(() => this.setModeCursor());
  }
}

class PopupComponent extends Component {
  css_boxShadow       = "0px 0px 20px #403f3f";
  css_borderRadius    = "10px";
  css_padding         = "15px";
  css_backgroundColor = "bodyBgColor";
  css_position        = "absolute";
  css_zIndex          = "100";
  css_marginTop       = "15vh";
  css_userSelect      = "none";

  isPopup = true;
  disableModes = false;

  show() {
    bodyComponent.hidePopups();
    if (this.disableModes) modeMaster.reset();
    super.show();
  }

  renderCallback() {
    this.hide();
  }

  defineTheme() {
    this.css("background", "bodyBgColor");
  }
}


class HelpComponent extends PopupComponent {
  accessibleBy = "helpComponent";

  css_width           = "500px";
  css_height          = "500px";
  css_marginLeft      = "calc(50vw - 250px)";
  css_overflow        = "scroll";
  css_scrollbarWidth  = "none";
  value               = `
<div style='text-align: center;'><h2>Welcome</h2>

<p>
This is one of the few well-equipped ASCII diagram builders freely available on the internet.
It stresses portability, simplicity, and immediateness. ASCII diagrams are
the best balance between pen to paper and advanced graphical builders, while also allowing
users to present visual information in places that can
only render text (such as in code, consoles, primitive displays, and so on).
</p>
<p>
By using text, you avoid the need for file formats, attaching documents and over-styled distractions.
</p>
<h2>FAQ</h2>
 <h4>ASCII or Unicode?</h4>
 Unicode is prettier but less reliable. Depending on where it's used,
 it could display in unexpected ways. Here, both modes try their best
 to use the most appropriate characters, but each mode does not promise
 absolute ASCII or Unicode. You can change mode in Settings.
 <h4>How do I export my drawing?</h4>
 Simply select Export on the top menu, and your drawing
 will be copied to your clipboard. A short link will be included
 so that you / others can edit the drawing later. It's recommended
 you keep this short link to avoid loosing the ability to find / edit it later.
 Exported drawings are immutable; editing via a short link is a copy of the original.
 <br><br>
 <b>Remember, the view in which you paste the drawing must use a fixed-width font,
 and have a width greater than what you've drawn or not wrap text.
 Otherwise you'll see a mess.</b>

 <h4>Why sign up?</h4>
 Only sign up if you care about managing and tracking your drawings.
 For convenience, your active drawing is saved to the browser, but 
 to save multiple reliably and cross-device, an account is recommended.
 Passwords are Bcrypt-10 encrypted.
 <h4>Account Management</h4>
 If you wish to delete your account, recover a lost account, or anything else,
 please get in touch at <b>casparwylie@gmail.com</b>, using the email you 
 originally signed up with.
 <h4>How do I contribute?</h4>
 Feel free to contribute on <a href="github.com/casparwylie/ascii">GitHub</a>.
 <h4>Feature requests?</h4>
 Please use the Issue Tracker on <a href="github.com/casparwylie/ascii">GitHub</a>.
 <h4></h4>
<h2>Usage</h2>
<h2>Shortcuts</h2>
</div>
<span style='white-space: pre-wrap'>
<b>ctrl-g</b>              Group
<b>ctrl-c</b>              Copy layer
<b>ctrl-z</b>              Undo
<b>ctrl-shift-z</b>        Redo
<b>ctrl-a</b>              Select all
<b>backspace/delete</b>    Delete layer
<b>shift-click</b>         Multi-select | single-select member of group.
<b>arrow keys</b>          Move layer
<b>ctrl-v</b>              Paste text (when editing text)
</span>
  `;

  defineChildren() {
    return [];
  }

  showIfFirstVisit() {
    if (!localStorage.getItem("visited")) {
      this.show();
    }
    localStorage.setItem("visited", true);
  }
}

class SettingsComponent extends PopupComponent {
  accessibleBy = "settingsComponent";

  css_width           = "300px";
  css_height          = "250px";
  css_marginLeft      = "calc(50vw - 150px)";

  charsetButtons = [
    new ButtonComponent({
      charsetId: "ascii",
      selectByDefault: charManager.getCharset() == "ascii",
      value: "ASCII",
      css_width: "50%",
      on_click: () => this.setCharset("ascii"),
    }),
    new ButtonComponent({
      charsetId: "unicode",
      selectByDefault: charManager.getCharset() == "unicode",
      value: "Unicode",
      css_width: "50%",
      on_click: () => this.setCharset("unicode"),
    }),
  ];
  themeButtons = [
    new ButtonComponent({
      themeId: "darkTheme",
      selectByDefault: themeManager.defaultTheme == "darkTheme",
      css_width: "33%",
      value: "Dark",
      on_click: () => this.setTheme("darkTheme")
    }),
    new ButtonComponent({
      themeId: "lightTheme",
      selectByDefault: themeManager.defaultTheme == "lightTheme",
      css_width: "33%",
      value: "Light",
      on_click: () => this.setTheme("lightTheme")
    }),
    new ButtonComponent({
      themeId: "consoleTheme",
      selectByDefault: themeManager.defaultTheme == "consoleTheme",
      css_width: "33%",
      value: "Console",
      on_click: () => this.setTheme("consoleTheme")
    }),
  ]

  setCharset(charsetId) {
    for (let button of this.charsetButtons) {
      button.charsetId == charsetId? button.select(): button.unselect();
    }
    charManager.setCharset(charsetId);
    layerManager.refresh(() => layerManager.renderCharset());
  }

  setTheme(themeId) {
    themeManager.setTheme(themeId);
    themeManager.renderTheme();
    for (let button of this.themeButtons) {
      button.themeId == themeId? button.select(): button.unselect();
    }
  }

  defineChildren() {
    return [
      new Component({
        css_fontSize: "50px",
        css_width: "100%",
        css_height: "15%",
        css_textAlign: "center",
        value: "⚙",
      }),
      new Component({css_textAlign: "center", css_marginTop: "30px", value: "Charset"}),
      new Component({
        css_display: "flex",
        css_columnGap: "3px",
        css_justifyContent: "space-between",
        css_width: "100%",
        css_marginTop: "5px",
        children: this.charsetButtons,
      }),
      new Component({css_textAlign: "center", css_marginTop: "20px", value: "Theme"}),
      new Component({
        css_display: "flex",
        css_columnGap: "3px",
        css_justifyContent: "space-between",
        css_width: "100%",
        css_marginTop: "5px",
        children: this.themeButtons,
      }),
    ]
  }
}


class ButtonComponent extends Component {

  type = "button"
  css_fontFamily       = "monospace";
  css_fontSize         = "11px";
  css_paddingBottom    = "3px";
  css_borderRadius     = "10px";
  css_height           = "40px";
  css_border           = "1px solid";
  css_userSelect       = "none";

  defineTheme() {
    this.css("backgroundColor", "buttonBgColor");
    this.css("borderColor", "buttonBorderColor");
    this.css("color", "buttonFgColor");
    this.selected? this.select(): this.unselect();
  }

  unselect() {
    this.selected = false;
    this.css("backgroundColor", "buttonBgColor");
  }

  select() {
    this.selected = true;
    this.css("backgroundColor", "buttonSelectedBgColor");
  }

  renderCallback() {
    if (this.selectByDefault) this.select();
  }

  on_mouseDown() {
    this.css("backgroundColor", "buttonClickBgColor");
  }

  on_mouseUp() {
    this.css("backgroundColor", "buttonBgColor");
  }
}


class MenuButtonComponent extends ButtonComponent {
  css_border           = "1px solid #212121";
  css_boxShadow        = "0px 0px 20px #403f3f";
  css_marginTop        = "10px";
}


class ModeMenuButtonComponent extends MenuButtonComponent {

  constructor (icon, name, showCondition, setModes, activeModes, callback=()=>{}) {
    super();
    /*
    name: display name of the button
    showCondition: A ModeMaster condition that gets checked every Menu.refresh
      call to show/hide the button.
    setModes: A ModeMaster update command when the button is pressed.
    activeModes: A ModeMaster condition to choose if the button is selected.
    callback: A function callback on press.
    */
    this.icon = icon;
    this.name = name;
    this.isConditional = Boolean(showCondition.length);
    this.showCondition = modeMaster.makeFunc(showCondition);
    this.callback = callback;
    this.setModes = modeMaster.makeFunc(setModes);
    this.activeModesCondition = activeModes.length? modeMaster.makeFunc(activeModes): () => false;
  }

  on_mouseDown() {
    this.setModes();
    this.callback();
    if (!this.activeModesCondition()) super.on_mouseDown();
  }

  on_mouseUp() {
    if (!this.activeModesCondition()) super.on_mouseUp();
  }


  defineChildren() {
    return [
      new Component({css_display: "inline-block", css_fontSize: "16px", value: this.icon}),
      new Component({css_display: "inline-block", css_marginLeft: "5px", value: this.name}),
    ]
  }

  isActive() {
    return this.activeModesCondition();
  }

  refresh() {
    this.hide();
    this.unselect();
    if (this.showCondition()) this.show();
    if (this.isActive()) this.select();
  }
}

class MenuButtonLeftComponent extends ModeMenuButtonComponent {
  css_width = "100%";
}


class MenuComponent extends Component {

  unselectAll() {
    this.buttons.forEach(button => button.unselect());
  }

  defineChildren() {
    return this.buttons;
  }
}

class ModeMenuComponent extends MenuComponent {
  refresh() {
    this.buttons.forEach(button => button.refresh());
  }

  renderCallback() {
    modeMaster.registerCallback(() => this.refresh());
    this.refresh();
  }
}


class MainMenuComponent extends ModeMenuComponent {
  css_top            = "0";
  css_left           = "0";
  css_right          = "0";
  css_bottom         = "0";
  css_display        = "flex";
  css_columnGap      = "3px";
  css_justifyContent = "space-between";
  css_margin         = "15px auto";
  css_width          = "fit-content";
  css_position       = "absolute";
  css_zIndex         = "100";
  css_height         = "7vh";

  buttons = [
    new ModeMenuButtonComponent("➤", "Select",
      [], [modeMaster.reset, "select"], [modeMaster.hasOr, "selected", "select"], () => layerManager.switchModeCallback()),
    new ModeMenuButtonComponent("◻", "Square",
      [], [modeMaster.reset, "draw", "square"], [modeMaster.isDrawyMode, "square"], () => layerManager.switchModeCallback()),
    new ModeMenuButtonComponent("◯", "Circle",
      [], [modeMaster.reset, "draw", "circle"], [modeMaster.isDrawyMode, "circle"], () => layerManager.switchModeCallback()),
    new ModeMenuButtonComponent("t",  "Text",
      [], [modeMaster.reset, "draw", "text"], [modeMaster.isDrawyMode, "text"], () => layerManager.switchModeCallback()),
    new ModeMenuButtonComponent("/", " Line",
      [], [modeMaster.reset, "draw", "line", "free-line"], [modeMaster.isDrawyMode, "free-line"], () => layerManager.switchModeCallback()),
    new ModeMenuButtonComponent("_|", "Step",
      [], [modeMaster.reset, "draw", "line", "step-line"], [modeMaster.isDrawyMode, "step-line"], () => layerManager.switchModeCallback()),
    new ModeMenuButtonComponent("_|‾", "Switch",
      [], [modeMaster.reset, "draw", "line", "switch-line"], [modeMaster.isDrawyMode, "switch-line"], () => layerManager.switchModeCallback()),
    new ModeMenuButtonComponent("◇", "Diamond",
      [], [modeMaster.reset, "draw", "diamond"], [modeMaster.isDrawyMode, "diamond"], () => layerManager.switchModeCallback()),
    new ModeMenuButtonComponent("᎒᎒᎒", "Table",
      [], [modeMaster.reset, "draw", "table"], [modeMaster.isDrawyMode, "table"], () => layerManager.switchModeCallback()),
    new ModeMenuButtonComponent("∿", "Free",
      [], [modeMaster.reset, "draw", "free"], [modeMaster.isDrawyMode, "free"], () => FreeLayer.startFreeDraw()),
    new ModeMenuButtonComponent("⌫", "Erase",
      [], [modeMaster.reset, "erase", "ebutton"], [modeMaster.hasOr, "erasing", "erase"], () => layerManager.switchModeCallback()),
    new ModeMenuButtonComponent("↺", "Undo",
      [], [], [], (event) => layerManager.undoEvent(event)),
    new ModeMenuButtonComponent("↻", "Redo",
      [], [], [], (event) => layerManager.redoEvent(event)),
    new ModeMenuButtonComponent("x", "Restart",
      [], [], [], () => layerManager.refresh(() => layerManager.empty())),
    new ModeMenuButtonComponent("->", "<b>Export</b>",
      [], [], [], () => canvas.exportToClipboard()),
    new ModeMenuButtonComponent("⚙", "<b>Settings</b>",
      [], [], [], () => bodyComponent.settingsComponent.toggle()),
    new ModeMenuButtonComponent("?", "<b>Help</b>",
      [], [], [], () => bodyComponent.helpComponent.toggle()),
  ]
}

class LeftMenuComponent extends ModeMenuComponent {
  css_height    = "100vh";
  css_width     = "130px";
  css_float     = "left";
  css_position  = "relative";
  css_zIndex    = "100";
  css_marginTop = "120px";

  drawFreeOptions = [
    ["_lines", "-|", "lines"],
    ["█", "█", "fill"],
    ["x", "x", "character"],
    ["*", "*", "character"],
    [".", ".", "character"],
    ["+", "+", "character"],
    ["•", "•", "character"],
    [">", ">", "character"],
    ["<", "<", "character"],
  ];


  buttons = [
    new MenuButtonLeftComponent("⧉", "Copy",
      [modeMaster.has, "selected"], [], [], (event) => layerManager.copySelectedLayersEvent(event)),
    new MenuButtonLeftComponent("⧓", "Group",
      [modeMaster.has, "multi-select", "selected"], [], [], (event) => layerManager.groupSelectedLayersEvent(event)),
    new MenuButtonLeftComponent("⧎", "Ungroup",
      [modeMaster.has, "multi-select", "selected"], [], [], (event) => layerManager.ungroupSelectedLayersEvent(event)),
    new MenuButtonLeftComponent("✕", "Delete",
      [modeMaster.has, "selected"], [modeMaster.reset, "select"], [], (event) => layerManager.deleteLayersEvent(event)),
    new MenuButtonLeftComponent("⎘", "Forward",
      [modeMaster.has, "selected"], [], [], (event) => layerManager.bringForwardEvent(event)),
    new MenuButtonLeftComponent("⎗", "Backwards",
      [modeMaster.has, "selected"], [], [], (event) => layerManager.sendBackwardsEvent(event)),
    new MenuButtonLeftComponent("⎘", "Front",
      [modeMaster.has, "selected"], [], [], (event) => layerManager.bringToFrontEvent(event)),
    new MenuButtonLeftComponent("⎗", "Back",
      [modeMaster.has, "selected"], [], [], (event) => layerManager.sendToBackEvent(event)),
    new MenuButtonLeftComponent("⏴", "Arrow",
      [modeMaster.has, "selected", "line"], [], [], () => layerManager.redrawLinesEvent("left")),
    new MenuButtonLeftComponent("⏵", "Arrow",
      [modeMaster.has, "selected", "line"], [], [], () => layerManager.redrawLinesEvent("right")),
    new MenuButtonLeftComponent("⋮", "Dotted",
      [modeMaster.has, "selected", "line-based"], [], [], () => layerManager.redrawLineBasedEvent("dotted")),
    new MenuButtonLeftComponent("--", "Dashed",
      [modeMaster.has, "selected", "line-based"], [], [], () => layerManager.redrawLineBasedEvent("dashed")),
    new MenuButtonLeftComponent("―", "Solid",
      [modeMaster.has, "selected", "line-based"], [], [], () => layerManager.redrawLineBasedEvent("solid-thin")),
    new MenuButtonLeftComponent("―", "Solid bold",
      [modeMaster.has, "selected", "line-based"], [], [], () => layerManager.redrawLineBasedEvent("solid-bold")),
  ]

  drawFreeButtons() {
    let buttons = [];
    for (let [char, icon, name] of this.drawFreeOptions) {
      buttons.push(
        new MenuButtonLeftComponent(
          icon,
          name,
          [modeMaster.has, "draw", "free"],
          [modeMaster.reset, "draw", "free", "dfbutton", char], [modeMaster.has, char], (event) => FreeLayer.setFreeChar(char)
        )
      )
    }
    return buttons;
  }

  refresh() {
    super.refresh();
    this.hide();
    if (this.buttons.map(button => button.showCondition()).some(Boolean)) this.show();
  }

  defineChildren() {
    this.buttons = this.buttons.concat(this.drawFreeButtons());
    return super.defineChildren();
  }
}


class CanvasDumpComponent extends Component {
  accessibleBy = "canvasDumpComponent";

  // We never display this, but export uses this
  // to output before copying to preserve styling.
  // If a user pastes an export in the same browser,
  // the following styles can get preserved.
  // Otherwise, good luck!
  css_fontFamily      = "monospace";
  css_backgroundColor = "white";
  css_color           = "black";
  css_whiteSpace      = "pre-wrap";
  // Hide far away (body overflow is hidden)
  css_position         = "absolute";
  css_marginLeft       = "500vw";
}


class InformerComponent extends Component {
  accessibleBy = "informerComponent"

  css_width            = "30%";
  css_marginLeft       = "35%";
  css_position         = "absolute";
  css_marginTop        = "80vh";
  css_borderRadius     = "10px";
  css_boxShadow        = "0px 0px 20px grey";
  css_fontSize         = "15px";
  css_padding          = "5px";
  css_textAlign        = "center";
  css_textWeight       = "bold";
  css_zIndex           = "100";

  defineTheme() {
    this.css("color", "bodyFgColor");
  }

  defineChildren() {
    return [
      new Component({
        accessibleBy: "moodCharComponent",
        css_fontSize: "25px",
        type: "span",
        css_verticalAlign: "middle",
      }),
      new Component({
        accessibleBy: "messageComponent",
        css_marginLeft: "10px",
        type: "span",
        css_verticalAlign: "middle",
      }),
    ]
  }

  report(message, mood, time=null) {
    if (time == null) time = message.length * 150;
    if (time == -1) time = 100000000;
    let moodChar = "";
    switch (mood) {
      case "good":
        this.css("backgroundColor", "informerGoodBgColor");
        this.css("color", "informerGoodFgColor");
        moodChar = "✓";
      break;
      case "bad":
        this.css("backgroundColor", "informerBadBgColor");
        this.css("color", "informerBadFgColor");
        moodChar = "✕";
      break;
      default:
        this.css("backgroundColor", "informerDefaultBgColor");
        this.css("color", "informerDefaultFgColor");
    }
    this.messageComponent.setValue(message);
    this.moodCharComponent.setValue(moodChar);
    this.show();
    setTimeout(() => this.hide(), time);
  }

  loading() {
    this.report("Loading...", "", -1);
  }

  loadingFinish() {
    this.hide();
  }

  renderCallback() {
    this.hide();
  }
}


class Body extends Component {
  type = "body";
  css_overflow = "hidden";

  assignParent(parent) {
    this.parent = document;
    this.parent.body = this.element;
  }

  defineChildren() {
    return [
      new InformerComponent(),
      new SettingsComponent(),
      new HelpComponent(),
      new MainMenuComponent(),
      new LeftMenuComponent(),
      new CanvasComponent(),
      new CanvasDumpComponent(),
    ];
  }

  hidePopups() {
    this.children.filter(child => child.isPopup).forEach(child => child.hide());
  }

  defineTheme() {
    this.css("backgroundColor", "bodyBgColor");
    this.css("color", "bodyFgColor");
    this.css("fontFamily", "bodyFont");
  }
}


function main() {
  layerManager         = new LayerManager();
  modeMaster           = new ModeMaster();
  areaSelectManager    = new AreaSelectManager();
  eventManager         = new EventManager();
  externalHookManager  = new BaseExternalHookManager();
  charManager          = new CharManager();
  themeManager         = new ThemeManager();

  bodyComponent = new Body();
  bodyComponent.render();


  canvas = bodyComponent.canvasComponent;
  eventManager.assignAll(
    {window: window, document: document, canvas: canvas.element}
  );

  layerManager.importFromLocalStorage();

  bodyComponent.helpComponent.showIfFirstVisit();
}

main(); // :)
</script>

<!-- By design, this can happily 404 and run without a backend -->
<script src="/static/serverLink.js"></script>
